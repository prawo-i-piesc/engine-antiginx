{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\u2699\ufe0f Engine-AntiGinx","text":""},{"location":"#about-the-project","title":"About the Project","text":"<p>Engine-AntiGinx is a security scanning tool designed to analyze websites and detect potential vulnerabilities and security misconfigurations. Built with Go, it performs concurrent security tests on web applications and reports findings with structured threat levels aligned with CVSS severity ratings.</p> <p>The project consists of two main components: - App - CLI security scanner for direct usage - Engined - Background daemon that consumes tasks from RabbitMQ queue</p>"},{"location":"#technologies","title":"Technologies","text":"Technology Description \ud83c\udfaf Go 1.25 Main programming language \ud83d\udc30 RabbitMQ Message queue for async task processing \ud83d\udc33 Docker Containerization with multi-arch build (amd64/arm64) \ud83d\udc19 Docker Compose Multi-container orchestration \ud83d\udd04 GitHub Actions CI/CD: build, tests, release, documentation \ud83d\udce6 GHCR GitHub Container Registry for Docker images \ud83d\udcda MkDocs Documentation with Material theme on GitHub Pages"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>Engine-AntiGinx/\n\u251c\u2500\u2500 App/                      # CLI Security Scanner\n\u2502   \u251c\u2500\u2500 main.go               # App entry point\n\u2502   \u251c\u2500\u2500 CVE/                  # CVE vulnerability assessment (NIST NVD)\n\u2502   \u251c\u2500\u2500 Errors/               # Structured error handling\n\u2502   \u251c\u2500\u2500 Helpers/              # Utility functions\n\u2502   \u251c\u2500\u2500 HTTP/                 # HTTP client with anti-bot detection\n\u2502   \u251c\u2500\u2500 Parameter-Parser/     # CLI argument parser\n\u2502   \u251c\u2500\u2500 Registry/             # Test registry system\n\u2502   \u251c\u2500\u2500 Reporter/             # Results reporter (CLI/Backend)\n\u2502   \u251c\u2500\u2500 Runner/               # Job orchestrator\n\u2502   \u2514\u2500\u2500 Tests/                # Security test implementations\n\u251c\u2500\u2500 Engined/                  # Background Daemon\n\u2502   \u2514\u2500\u2500 main.go               # RabbitMQ consumer daemon\n\u251c\u2500\u2500 docs/                     # MkDocs documentation\n\u251c\u2500\u2500 docker-compose.yml        # Container orchestration\n\u251c\u2500\u2500 Dockerfile                # Multi-stage Docker build\n\u251c\u2500\u2500 mkdocs.yml                # Documentation configuration\n\u251c\u2500\u2500 go.mod                    # Go module dependencies\n\u2514\u2500\u2500 .env.example              # Environment variables template\n</code></pre>"},{"location":"#core-components","title":"Core Components","text":""},{"location":"#app-cli-scanner","title":"App (CLI Scanner)","text":"<ul> <li>CVE - Integration with NIST NVD API for CVE vulnerability assessment</li> <li>Errors - Structured error handling with error codes (100-499 ranges)</li> <li>Helpers - String utilities (case-insensitive search, deduplication)</li> <li>HTTP - HTTP client wrapper with anti-bot detection (Cloudflare, CAPTCHA)</li> <li>Parameter-Parser - CLI argument parser with validation and whitelist support</li> <li>Registry - Thread-safe test registry for managing security tests</li> <li>Reporter - Async results reporter (CLI output or HTTP backend)</li> <li>Runner - Job orchestrator using goroutines and fan-out pattern</li> <li>Tests - Security test implementations:</li> <li><code>https</code> - HTTPS protocol verification</li> <li><code>hsts</code> - HTTP Strict Transport Security analysis</li> <li><code>serv-h-a</code> - Server header information disclosure</li> <li><code>x-frame</code> - X-Frame-Options clickjacking protection</li> </ul>"},{"location":"#engined-daemon","title":"Engined (Daemon)","text":"<ul> <li>RabbitMQ consumer listening on <code>scan_queue</code></li> <li>Spawns App scanner for each incoming task</li> <li>Graceful shutdown on SIGINT</li> <li>ACK/NACK handling for message reliability</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.25 or higher (download here)</li> <li>Docker &amp; Docker Compose (optional)</li> <li>RabbitMQ (for Engined daemon)</li> </ul>"},{"location":"#running-app-locally","title":"Running App Locally","text":"<pre><code># Clone the repository\ngit clone https://github.com/prawo-i-piesc/Engine-AntiGinx.git\ncd Engine-AntiGinx\n\n# Run security scan\ngo run ./App/main.go test --target example.com --tests https hsts serv-h-a\n</code></pre>"},{"location":"#running-with-docker-compose","title":"Running with Docker Compose","text":"<pre><code># Copy and configure environment\ncp .env.example .env\n# Edit .env with your settings\n\n# Build and run\ndocker compose up --build\n</code></pre>"},{"location":"#environment-variables","title":"Environment Variables","text":"Variable Description Example <code>RABBITMQ_URL</code> RabbitMQ connection string <code>amqp://guest:guest@localhost:5672/</code> <code>BACK_URL</code> Backend API URL for reporting <code>http://backend:3000/api/results</code> <code>ENGINE_ANTIGINX_DAEMON_PORT</code> Engined exposed port <code>9090</code> <code>ENGINE_ANTIGINX_APP_PORT</code> App exposed port <code>8080</code>"},{"location":"#using-pre-built-docker-image","title":"Using Pre-built Docker Image","text":"<pre><code># Pull the latest image\ndocker pull ghcr.io/prawo-i-piesc/engine-antiginx:latest\n\n# Run the scanner\ndocker run ghcr.io/prawo-i-piesc/engine-antiginx:latest /engine-antiginx/App test --target example.com --tests https\n</code></pre>"},{"location":"#available-security-tests","title":"Available Security Tests","text":"Test ID Name Description <code>https</code> HTTPS Protocol Verification Checks if connection uses encrypted HTTPS <code>hsts</code> HSTS Header Analysis Analyzes HTTP Strict Transport Security config <code>serv-h-a</code> Server Header Analysis Detects technology disclosure + CVE assessment <code>x-frame</code> X-Frame-Options Check Validates clickjacking protection headers"},{"location":"#links","title":"Links","text":"<ul> <li>\ud83d\udce6 GitHub Repository</li> <li>\ud83d\udc33 Container Images (GHCR)</li> <li>\ud83d\udcda Documentation (GitHub Pages)</li> <li>\ud83d\ude80 GitHub Actions</li> <li>\ud83d\udcdd License</li> </ul>"},{"location":"App/","title":"App","text":""},{"location":"App/#app","title":"App","text":"<pre><code>import \"Engine-AntiGinx/App\"\n</code></pre> <p>Package main provides the entry point for the Engine-AntiGinx security scanner command-line application.</p> <p>This application performs security assessments on web targets by executing various security tests including HTTPS verification, HSTS analysis, and server header information disclosure detection.</p> <p>Usage:</p> <pre><code>engine-antiginx test --target &lt;url&gt; --tests &lt;test_ids...&gt;\n</code></pre> <p>Example:</p> <pre><code># Run HTTPS and HSTS tests on example.com\nengine-antiginx test --target example.com --tests https hsts\n\n# Run all available tests\nengine-antiginx test --target example.com --tests https hsts serv-h-a\n</code></pre> <p>Available Tests:</p> <ul> <li>https: Verifies HTTPS protocol usage</li> <li>hsts: Analyzes HTTP Strict Transport Security headers</li> <li>serv-h-a: Server header analysis for information disclosure</li> </ul> <p>The application follows a modular architecture:</p> <ol> <li>Parameter parser: Extracts command-line arguments</li> <li>Job Runner: Orchestrates test execution</li> <li>Test Registry: Provides access to available security tests</li> <li>Reporter: Outputs results to CLI or backend API</li> <li>GlobalHandler: Reports errors to CLI or Queue Consumer</li> </ol>"},{"location":"App/#index","title":"Index","text":"<ul> <li>func main()</li> </ul>"},{"location":"App/#func-main","title":"func main","text":"<pre><code>func main()\n</code></pre> <p>main is the entry point of the Engine-AntiGinx security scanner. It bootstraps the application by determining the execution mode (CLI vs. Backend) and initializing the global error handling mechanism.</p> <p>Mode Selection: The function checks for the existence of the \"BACK_URL\" environment variable:</p> <ul> <li>If PRESENT: Treats execution as a Backend Worker (cliMode = false). Errors will be formatted as JSON for machine consumption.</li> <li>If ABSENT: Treats execution as a standalone CLI tool (cliMode = true). Errors will be formatted as human-readable text blocks.</li> </ul> <p>execution Flow:</p> <ol> <li>Detect execution mode via os.LookupEnv(\"BACK_URL\").</li> <li>Initialize GlobalHandler with the calculated mode.</li> <li>Delegate full control to errorHandler.RunSafe(), which encapsulates argument parsing, job orchestration, and panic recovery.</li> </ol> <p>Generated by gomarkdoc</p>"},{"location":"App/CVE/","title":"CVE","text":""},{"location":"App/CVE/#cve","title":"CVE","text":"<pre><code>import \"Engine-AntiGinx/App/CVE\"\n</code></pre> <p>Package CVE provides functionality for querying and analyzing Common Vulnerabilities and Exposures (CVE) from the NIST National Vulnerability Database (NVD). It enables security assessment of detected technologies by checking for known vulnerabilities and calculating risk levels based on CVSS scores.</p>"},{"location":"App/CVE/#index","title":"Index","text":"<ul> <li>func GetThreatLevelFromAssessment(assessment *VulnerabilityAssessment) int</li> <li>func buildSearchQuery(technology, version string) string</li> <li>func normalizeTechnologyName(technology string) string</li> <li>type CVEClient</li> <li>func NewCVEClient() *CVEClient</li> <li>func (c *CVEClient) AssessTechnologyVulnerabilities(technology, version string) (*VulnerabilityAssessment, error)</li> <li>func (c *CVEClient) analyzeCVEs(technology, version string, cves []CVEResult) *VulnerabilityAssessment</li> <li>func (c *CVEClient) convertNVDToCVEResults(nvdResp NVDResponse) []CVEResult</li> <li>func (c *CVEClient) determineRiskLevel(assessment *VulnerabilityAssessment) string</li> <li>func (c *CVEClient) searchCVEs(technology, version string) ([]CVEResult, error)</li> <li>type CVEResult</li> <li>type NVDResponse</li> <li>type VulnerabilityAssessment</li> </ul>"},{"location":"App/CVE/#func-getthreatlevelfromassessment","title":"func GetThreatLevelFromAssessment","text":"<pre><code>func GetThreatLevelFromAssessment(assessment *VulnerabilityAssessment) int\n</code></pre> <p>GetThreatLevelFromAssessment converts CVE risk level to the Tests package ThreatLevel enum. This function provides integration between CVE assessment results and the test framework's threat classification system.</p> <p>Mapping:</p> <ul> <li>CRITICAL \u2192 5 (Critical threat)</li> <li>HIGH \u2192 4 (High threat)</li> <li>MEDIUM \u2192 3 (Medium threat)</li> <li>LOW \u2192 2 (Low threat)</li> <li>NONE \u2192 0 (No threat)</li> <li>default \u2192 1 (Info level)</li> </ul> <p>Parameters:</p> <ul> <li>assessment: VulnerabilityAssessment containing the risk level</li> </ul> <p>Returns:</p> <ul> <li>int: ThreatLevel value compatible with Tests.ThreatLevel enum</li> </ul> <p></p>"},{"location":"App/CVE/#func-buildsearchquery","title":"func buildSearchQuery","text":"<pre><code>func buildSearchQuery(technology, version string) string\n</code></pre> <p>buildSearchQuery creates an optimized search query for the NVD API by combining technology name and version. If version is not available or set to \"detected\", it searches only by technology name.</p> <p>Parameters:</p> <ul> <li>technology: Technology name to search for</li> <li>version: Technology version (optional, can be empty or \"detected\")</li> </ul> <p>Returns:</p> <ul> <li>string: Formatted search query for the NVD API</li> </ul> <p></p>"},{"location":"App/CVE/#func-normalizetechnologyname","title":"func normalizeTechnologyName","text":"<pre><code>func normalizeTechnologyName(technology string) string\n</code></pre> <p>normalizeTechnologyName standardizes technology names to match how they appear in the NVD database. This improves search accuracy by mapping common technology names to their official NVD identifiers.</p> <p>Parameters:</p> <ul> <li>technology: Original technology name (e.g., \"Apache\", \"Nginx\")</li> </ul> <p>Returns:</p> <ul> <li>string: Normalized technology name for NVD search (e.g., \"apache http server\", \"nginx\")</li> </ul> <p>Supported technologies include web servers (Apache, Nginx, IIS), frameworks (Django, Laravel, Spring), and content management systems (WordPress, Drupal).</p> <p></p>"},{"location":"App/CVE/#type-cveclient","title":"type CVEClient","text":"<p>CVEClient handles communication with CVE databases, specifically the NIST NVD API. It provides methods for searching vulnerabilities and assessing security risks for specific technologies and versions.</p> <pre><code>type CVEClient struct {\n    httpClient *http.Client\n    baseURL    string\n}\n</code></pre> <p></p>"},{"location":"App/CVE/#func-newcveclient","title":"func NewCVEClient","text":"<pre><code>func NewCVEClient() *CVEClient\n</code></pre> <p>NewCVEClient creates a new CVE client instance configured to communicate with the NIST NVD API. The client is initialized with a 30-second timeout for HTTP requests and uses the official NVD CVE API 2.0 endpoint.</p> <p>Returns:</p> <ul> <li>*CVEClient: A ready-to-use CVE client instance</li> </ul> <p>Example:</p> <pre><code>client := NewCVEClient()\nassessment, err := client.AssessTechnologyVulnerabilities(\"nginx\", \"1.21.0\")\n</code></pre> <p></p>"},{"location":"App/CVE/#func-cveclient-assesstechnologyvulnerabilities","title":"func (*CVEClient) AssessTechnologyVulnerabilities","text":"<pre><code>func (c *CVEClient) AssessTechnologyVulnerabilities(technology, version string) (*VulnerabilityAssessment, error)\n</code></pre> <p>AssessTechnologyVulnerabilities checks for CVEs affecting a specific technology and version. It performs a comprehensive vulnerability assessment by querying the NVD database, analyzing the results, and calculating an overall risk level.</p> <p>The method normalizes technology names for better search accuracy and aggregates vulnerability data including severity counts and CVSS scores.</p> <p>Parameters:</p> <ul> <li>technology: Technology name (e.g., \"nginx\", \"Apache\", \"PHP\")</li> <li>version: Technology version string (e.g., \"1.21.0\", \"2.4.41\")</li> </ul> <p>Returns:</p> <ul> <li>*VulnerabilityAssessment: Complete assessment with CVEs and risk analysis</li> <li>error: Error if the search or analysis fails</li> </ul> <p>Example:</p> <pre><code>client := NewCVEClient()\nassessment, err := client.AssessTechnologyVulnerabilities(\"nginx\", \"1.21.0\")\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Printf(\"Found %d CVEs with risk level: %s\\n\", assessment.CVECount, assessment.RiskLevel)\n</code></pre> <p></p>"},{"location":"App/CVE/#func-cveclient-analyzecves","title":"func (*CVEClient) analyzeCVEs","text":"<pre><code>func (c *CVEClient) analyzeCVEs(technology, version string, cves []CVEResult) *VulnerabilityAssessment\n</code></pre> <p>analyzeCVEs performs comprehensive analysis on the CVE results to create a VulnerabilityAssessment. It categorizes CVEs by severity, finds the maximum CVSS score, and determines an overall risk level.</p> <p>Parameters:</p> <ul> <li>technology: Technology name being assessed</li> <li>version: Technology version being assessed</li> <li>cves: List of CVE entries to analyze</li> </ul> <p>Returns:</p> <ul> <li>*VulnerabilityAssessment: Complete assessment with aggregated statistics and risk level</li> </ul> <p></p>"},{"location":"App/CVE/#func-cveclient-convertnvdtocveresults","title":"func (*CVEClient) convertNVDToCVEResults","text":"<pre><code>func (c *CVEClient) convertNVDToCVEResults(nvdResp NVDResponse) []CVEResult\n</code></pre> <p>convertNVDToCVEResults converts NVD API response to our internal CVEResult format. It extracts essential information including CVE ID, description, CVSS scores, and severity ratings. Prefers CVSS v3.1 metrics over v2 when available.</p> <p>Parameters:</p> <ul> <li>nvdResp: Raw NVD API response structure</li> </ul> <p>Returns:</p> <ul> <li>[]CVEResult: Converted list of CVE entries in simplified format</li> </ul> <p></p>"},{"location":"App/CVE/#func-cveclient-determinerisklevel","title":"func (*CVEClient) determineRiskLevel","text":"<pre><code>func (c *CVEClient) determineRiskLevel(assessment *VulnerabilityAssessment) string\n</code></pre> <p>determineRiskLevel calculates overall risk based on CVE analysis using a weighted approach that considers both the number and severity of vulnerabilities.</p> <p>Risk levels are determined as follows:</p> <ul> <li>CRITICAL: Any HIGH/CRITICAL severity CVE present</li> <li>HIGH: 3 or more MEDIUM severity CVEs</li> <li>MEDIUM: Any MEDIUM severity CVE or 5+ LOW severity CVEs</li> <li>LOW: Any CVEs present that don't meet higher thresholds</li> <li>NONE: No CVEs found</li> </ul> <p>Parameters:</p> <ul> <li>assessment: VulnerabilityAssessment with severity counts</li> </ul> <p>Returns:</p> <ul> <li>string: Risk level classification (NONE, LOW, MEDIUM, HIGH, or CRITICAL)</li> </ul> <p></p>"},{"location":"App/CVE/#func-cveclient-searchcves","title":"func (*CVEClient) searchCVEs","text":"<pre><code>func (c *CVEClient) searchCVEs(technology, version string) ([]CVEResult, error)\n</code></pre> <p>searchCVEs performs the actual search against the NVD database using the CVE API 2.0. It constructs an HTTP request with appropriate headers, executes the search, and parses the JSON response into CVEResult structures.</p> <p>Parameters:</p> <ul> <li>technology: Normalized technology name</li> <li>version: Technology version string</li> </ul> <p>Returns:</p> <ul> <li>[]CVEResult: List of matching CVE entries</li> <li>error: Error if the request fails or response cannot be parsed</li> </ul> <p></p>"},{"location":"App/CVE/#type-cveresult","title":"type CVEResult","text":"<p>CVEResult represents a single CVE vulnerability entry with essential information including severity rating, CVSS score, and publication dates.</p> <pre><code>type CVEResult struct {\n    ID          string    `json:\"id\"`          // CVE identifier (e.g., \"CVE-2024-1234\")\n    Description string    `json:\"description\"` // Human-readable vulnerability description\n    Severity    string    `json:\"severity\"`    // Severity level: LOW, MEDIUM, HIGH, or CRITICAL\n    Score       float64   `json:\"score\"`       // CVSS base score (0.0-10.0)\n    Published   time.Time `json:\"published\"`   // Original publication date\n    Modified    time.Time `json:\"modified\"`    // Last modification date\n    References  []string  `json:\"references\"`  // External reference URLs\n}\n</code></pre> <p></p>"},{"location":"App/CVE/#type-nvdresponse","title":"type NVDResponse","text":"<p>NVDResponse represents the structure of NIST NVD API response (CVE API 2.0). This structure maps the JSON response from the National Vulnerability Database, including pagination information and vulnerability details with CVSS metrics.</p> <pre><code>type NVDResponse struct {\n    ResultsPerPage  int `json:\"resultsPerPage\"` // Number of results in current page\n    StartIndex      int `json:\"startIndex\"`     // Starting index for pagination\n    TotalResults    int `json:\"totalResults\"`   // Total number of matching results\n    Vulnerabilities []struct {\n        CVE struct {\n            ID          string `json:\"id\"`\n            Description struct {\n                DescriptionData []struct {\n                    Lang  string `json:\"lang\"`\n                    Value string `json:\"value\"`\n                } `json:\"description_data\"`\n            }   `json:\"description\"`\n            Published time.Time `json:\"published\"`\n            Modified  time.Time `json:\"lastModified\"`\n            Metrics   struct {\n                CVSSMetricV31 []struct {\n                    CVSSData struct {\n                        BaseScore    float64 `json:\"baseScore\"`\n                        BaseSeverity string  `json:\"baseSeverity\"`\n                    } `json:\"cvssData\"`\n                }   `json:\"cvssMetricV31\"`\n                CVSSMetricV2 []struct {\n                    CVSSData struct {\n                        BaseScore string `json:\"baseScore\"`\n                    } `json:\"cvssData\"`\n                }   `json:\"cvssMetricV2\"`\n            }   `json:\"metrics\"`\n        } `json:\"cve\"`\n    }   `json:\"vulnerabilities\"`\n}\n</code></pre> <p></p>"},{"location":"App/CVE/#type-vulnerabilityassessment","title":"type VulnerabilityAssessment","text":"<p>VulnerabilityAssessment contains comprehensive analysis results for a specific technology and version. It aggregates CVE data, categorizes vulnerabilities by severity, and provides an overall risk assessment.</p> <pre><code>type VulnerabilityAssessment struct {\n    Technology     string      `json:\"technology\"`      // Technology name (e.g., \"nginx\", \"Apache\")\n    Version        string      `json:\"version\"`         // Technology version (e.g., \"1.21.0\")\n    CVECount       int         `json:\"cve_count\"`       // Total number of CVEs found\n    HighSeverity   int         `json:\"high_severity\"`   // Count of HIGH/CRITICAL severity CVEs\n    MediumSeverity int         `json:\"medium_severity\"` // Count of MEDIUM severity CVEs\n    LowSeverity    int         `json:\"low_severity\"`    // Count of LOW severity CVEs\n    MaxScore       float64     `json:\"max_score\"`       // Highest CVSS score among all CVEs\n    CVEs           []CVEResult `json:\"cves\"`            // Complete list of CVE entries\n    RiskLevel      string      `json:\"risk_level\"`      // Overall risk: NONE, LOW, MEDIUM, HIGH, or CRITICAL\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"App/Errors/","title":"Errors","text":""},{"location":"App/Errors/#errors","title":"Errors","text":"<pre><code>import \"Engine-AntiGinx/App/Errors\"\n</code></pre> <p>Package Errors provides structured error handling with error codes and categorization for different failure scenarios across the Engine-AntiGinx application. It implements a panic-based error system with detailed error information including source tracking and retry capability indication.</p>"},{"location":"App/Errors/#index","title":"Index","text":"<ul> <li>type Error</li> <li>func (e *Error) Error() string</li> </ul>"},{"location":"App/Errors/#type-error","title":"type Error","text":"<p>Error represents a structured error with additional context for debugging and error handling. It implements the standard error interface and provides rich error information including error codes, source component identification, and retry capability flags.</p> <p>The Error type is used throughout the application for consistent error reporting and includes the following categories by code ranges:</p> <ul> <li>100-199: General and request creation errors</li> <li>200-299: Network and response errors</li> <li>300-399: Bot protection and security errors</li> <li>400-499: Parsing and validation errors</li> </ul> <p>Fields:</p> <ul> <li>Code: Numeric error code for categorization and programmatic handling</li> <li>Message: Human-readable error description with context</li> <li>Source: Component or package name where the error originated</li> <li>IsRetryable: Indicates whether the operation can be safely retried</li> </ul> <pre><code>type Error struct {\n    Code        int    `json:\"Code\"`\n    Message     string `json:\"Message\"`\n    Source      string `json:\"Source\"`\n    IsRetryable bool   `json:\"IsRetryable\"`\n}\n</code></pre> <p></p>"},{"location":"App/Errors/#func-error-error","title":"func (*Error) Error","text":"<pre><code>func (e *Error) Error() string\n</code></pre> <p>Error returns a formatted string representation of the error, implementing the error interface. The format includes the source component, error code, message, and retry capability.</p> <p>Returns:</p> <ul> <li>string: Formatted error message in the format \"[Source] Error Code: Message (Retryable: bool)\"</li> </ul> <p>Example output:</p> <pre><code>[HTTP] Error 101: Network timeout occurred (Retryable: true)\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"App/GlobalHandler/","title":"Index","text":""},{"location":"App/GlobalHandler/#globalhandler","title":"GlobalHandler","text":"<pre><code>import \"Engine-AntiGinx/App/GlobalHandler\"\n</code></pre>"},{"location":"App/GlobalHandler/#index","title":"Index","text":"<ul> <li>type ErrorHandler</li> <li>func InitializeErrorHandler(cliMode bool) *ErrorHandler</li> <li>func (e *ErrorHandler) RunSafe()</li> <li>func (e *ErrorHandler) printError(err Errors.Error)</li> </ul>"},{"location":"App/GlobalHandler/#type-errorhandler","title":"type ErrorHandler","text":"<p>ErrorHandler serves as the global safety net and execution controller for the application. It is responsible for wrapping the main application logic within a panic-recovery boundary and formatting any resulting errors according to the selected output mode (CLI or JSON).</p> <pre><code>type ErrorHandler struct {\n    cliMode bool\n}\n</code></pre> <p></p>"},{"location":"App/GlobalHandler/#func-initializeerrorhandler","title":"func InitializeErrorHandler","text":"<pre><code>func InitializeErrorHandler(cliMode bool) *ErrorHandler\n</code></pre> <p>InitializeErrorHandler creates a new instance of the global error handler.</p> <p>It configures the reporting mode based on the cliMode flag. This instance is intended to be used at the very top level of the application (typically in main.go) to ensure all unhandled panics are caught and reported gracefully.</p> <p>Parameters:</p> <ul> <li>cliMode: If true, errors are printed in a human-readable text block. If false, errors are printed as structured JSON objects for machine consumption.</li> </ul> <p>Returns:</p> <ul> <li>*ErrorHandler: A pointer to the configured handler instance ready to execute RunSafe().</li> </ul> <p></p>"},{"location":"App/GlobalHandler/#func-errorhandler-runsafe","title":"func (*ErrorHandler) RunSafe","text":"<pre><code>func (e *ErrorHandler) RunSafe()\n</code></pre> <p>RunSafe executes the main application flow within a protected scope. This is the entry point for the business logic, triggering argument parsing, parameter formatting, and job orchestration.</p> <p>The function establishes a defer/recover block to intercept any panics that occur during execution. It acts as a \"try-catch\" mechanism for the entire process, ensuring that the application never crashes with a raw stack trace but instead exits with a controlled error message and status code.</p> <p>Panic Recovery Strategy:</p> <ul> <li>Errors.Error: Handled directly, preserving the original code and message.</li> <li>HttpClient.HttpError: Converted to a generic Errors.Error with \"Http Client\" source.</li> <li>default (runtime panics): Wrapped in a critical Errors.Error (code 999) with stack details.</li> </ul> <p>Execution Flow:</p> <ol> <li>Sets up panic recovery via defer/recover.</li> <li>Creates and runs the CommandParser to process os.Args.</li> <li>Initializes the ScanFormatter to transform raw parameters into an ExecutionPlan.</li> <li>Creates and runs the JobRunner to orchestrate the security tests.</li> <li>If a panic occurs, it is caught, printed to Stderr, and the process exits with code 1.</li> </ol> <p>Exit Behavior:</p> <ul> <li>On Success: The function returns normally (exit code 0).</li> <li>On Panic: The process terminates immediately with os.Exit(1).</li> </ul> <p>Example:</p> <pre><code>handler := GlobalHandler.InitializeErrorHandler(true)\n// Will run the app and print pretty errors to stderr if something explodes\nhandler.RunSafe()\n</code></pre> <p></p>"},{"location":"App/GlobalHandler/#func-errorhandler-printerror","title":"func (*ErrorHandler) printError","text":"<pre><code>func (e *ErrorHandler) printError(err Errors.Error)\n</code></pre> <p>printError writes the formatted error details to standard error (os.Stderr).</p> <p>The format is determined by the cliMode flag set during initialization. This abstraction allows the application to be used both by humans in a terminal and by automated workers/wrappers expecting JSON.</p> <p>Output Formats:</p> <ul> <li>CLI Mode (true): A visual, ASCII-formatted block containing Source, Exit Code, Message, and Retryable status.</li> <li>JSON Mode (false): A strict JSON object representing the Error struct.</li> </ul> <p>Parameters:</p> <ul> <li>err: The standardized Errors.Error object to display.</li> </ul> <p>Generated by gomarkdoc</p>"},{"location":"App/HTTP/","title":"HTTP","text":""},{"location":"App/HTTP/#httpclient","title":"HttpClient","text":"<pre><code>import \"Engine-AntiGinx/App/HTTP\"\n</code></pre> <p>Package HttpClient provides an advanced HTTP client wrapper with bot protection detection and anti-detection capabilities. It wraps Go's standard http.Client with additional features including Cloudflare detection, stealth headers, TLS fingerprint masking, and human-like behavior simulation.</p> <p>The package supports multiple protection levels and can be configured to bypass common bot detection mechanisms while maintaining legitimate scanning capabilities.</p>"},{"location":"App/HTTP/#index","title":"Index","text":"<ul> <li>func defaultHeaders() map[string]string</li> <li>func getAntiDetectionHeaders() map[string]string</li> <li>func getBrowserTLSConfig() *tls.Config</li> <li>func getRandomUserAgent() string</li> <li>type HttpError</li> <li>type WrapperOption</li> <li>func WithAntiBotDetection() WrapperOption</li> <li>func WithHeaders(h map[string]string) WrapperOption</li> <li>type httpWrapper</li> <li>func CreateHttpWrapper(opts ...WrapperOption) *httpWrapper</li> <li>func (hw *httpWrapper) Get(url string, opts ...WrapperOption) *http.Response</li> <li>type httpWrapperConfig</li> </ul>"},{"location":"App/HTTP/#func-defaultheaders","title":"func defaultHeaders","text":"<pre><code>func defaultHeaders() map[string]string\n</code></pre> <p>defaultHeaders returns the default HTTP headers used by the AntiGinx scanner. These headers identify the client as AntiGinx/1.0 for legitimate scanning purposes.</p> <p>Returns:</p> <ul> <li>map[string]string: Default headers with User-Agent set to \"AntiGinx/1.0\"</li> </ul> <p></p>"},{"location":"App/HTTP/#func-getantidetectionheaders","title":"func getAntiDetectionHeaders","text":"<pre><code>func getAntiDetectionHeaders() map[string]string\n</code></pre> <p>getAntiDetectionHeaders returns comprehensive browser headers with maximum stealth capabilities. This function provides the best security by including all browser characteristics, client hints, viewport information, device capabilities, and network conditions that match a real Chrome browser.</p> <p>Includes enhanced features for maximum protection:</p> <ul> <li>Full Chrome client hints (viewport, DPR, device memory, architecture)</li> <li>Browser feature detection headers (Save-Data, RTT, ECT, Downlink)</li> <li>Color scheme and motion preferences</li> <li>Complete platform and architecture information</li> <li>Security fetch metadata and all standard browser headers</li> </ul> <p>Returns:</p> <ul> <li>map[string]string: Comprehensive headers for maximum anti-detection protection</li> </ul> <p></p>"},{"location":"App/HTTP/#func-getbrowsertlsconfig","title":"func getBrowserTLSConfig","text":"<pre><code>func getBrowserTLSConfig() *tls.Config\n</code></pre> <p>getBrowserTLSConfig returns a TLS configuration that mimics real browser behavior including cipher suites, curve preferences, and protocol versions that match Chrome/Firefox. This helps avoid TLS fingerprinting which is used by advanced bot detection systems.</p> <p>Configuration includes:</p> <ul> <li>TLS 1.2 and 1.3 support</li> <li>Modern cipher suites (AES-GCM, ChaCha20-Poly1305)</li> <li>Realistic curve preferences (X25519, P-256, P-384)</li> <li>HTTP/2 and HTTP/1.1 ALPN support</li> </ul> <p>Returns:</p> <ul> <li>*tls.Config: Browser-like TLS configuration</li> </ul> <p></p>"},{"location":"App/HTTP/#func-getrandomuseragent","title":"func getRandomUserAgent","text":"<pre><code>func getRandomUserAgent() string\n</code></pre> <p>getRandomUserAgent returns a random realistic user agent from a pool of current browser versions. This helps avoid fingerprinting by varying the user agent across requests, simulating traffic from different browsers and operating systems.</p> <p>Includes user agents for:</p> <ul> <li>Chrome on Windows, macOS, and Linux</li> <li>Firefox on Windows, macOS, and Linux</li> <li>Safari on macOS</li> <li>Edge on Windows</li> </ul> <p>Returns:</p> <ul> <li>string: A randomly selected user agent string</li> </ul> <p></p>"},{"location":"App/HTTP/#type-httperror","title":"type HttpError","text":"<p>HttpError represents an HTTP-related Error with structured information for debugging. It is used internally for panic-based Error handling throughout the HTTP client operations.</p> <p>Error codes:</p> <ul> <li>100: Request creation Error</li> <li>101: Network Error (DNS, timeout, connection issues)</li> <li>102: HTTP status Error (non-200 responses)</li> <li>200: Response body reading Error</li> <li>300: Bot protection detected</li> </ul> <pre><code>type HttpError struct {\n    Url         string // The URL that caused the Error\n    Code        int    // Error Code for categorization\n    Message     string // Human-readable Error description\n    Error       any    // Original Error object or response\n    IsRetryable bool   // Check if error is retryable\n}\n</code></pre> <p></p>"},{"location":"App/HTTP/#type-wrapperoption","title":"type WrapperOption","text":"<p>WrapperOption is a functional option type for configuring the HTTP wrapper. It allows flexible, composable configuration through functions like WithHeaders and WithAntiBotDetection.</p> <pre><code>type WrapperOption func(*httpWrapperConfig)\n</code></pre> <p></p>"},{"location":"App/HTTP/#func-withantibotdetection","title":"func WithAntiBotDetection","text":"<pre><code>func WithAntiBotDetection() WrapperOption\n</code></pre> <p>WithAntiBotDetection enables comprehensive anti-bot detection bypass with maximum protection. This option activates all available techniques including realistic headers, TLS fingerprint masking, cookie handling, random delays, and header ordering.</p> <p>When enabled, the client will:</p> <ul> <li>Use browser-like TLS configuration</li> <li>Maintain cookie jar for session handling</li> <li>Add realistic delays between requests (1-3 seconds)</li> <li>Randomize user agents</li> <li>Order headers like real browsers</li> <li>Support HTTP/2</li> <li>Use advanced stealth headers with all client hints and browser characteristics</li> </ul> <p>Returns:</p> <ul> <li>WrapperOption: Configuration function that enables anti-bot detection features</li> </ul> <p>Example:</p> <pre><code>wrapper := CreateHttpWrapper(WithAntiBotDetection())\n</code></pre> <p></p>"},{"location":"App/HTTP/#func-withheaders","title":"func WithHeaders","text":"<pre><code>func WithHeaders(h map[string]string) WrapperOption\n</code></pre> <p>WithHeaders creates a WrapperOption that adds or overrides HTTP headers in the client configuration. This option can be used both when creating the wrapper and on individual requests.</p> <p>Headers provided through this option will merge with existing headers, with new values overriding existing ones for the same header name.</p> <p>Parameters:</p> <ul> <li>h: Map of header names to values</li> </ul> <p>Returns:</p> <ul> <li>WrapperOption: Configuration function that applies the headers</li> </ul> <p>Example:</p> <pre><code>wrapper := CreateHttpWrapper(WithHeaders(map[string]string{\n    \"Authorization\": \"Bearer token123\",\n    \"Custom-Header\": \"value\",\n}))\n</code></pre> <p></p>"},{"location":"App/HTTP/#type-httpwrapper","title":"type httpWrapper","text":"<p>httpWrapper wraps Go's standard http.Client with additional bot protection detection and anti-detection capabilities. It provides a higher-level interface for making HTTP requests while handling common security scanning challenges.</p> <pre><code>type httpWrapper struct {\n    client *http.Client      // Underlying HTTP client\n    config httpWrapperConfig // Wrapper configuration including headers and settings\n}\n</code></pre> <p></p>"},{"location":"App/HTTP/#func-createhttpwrapper","title":"func CreateHttpWrapper","text":"<pre><code>func CreateHttpWrapper(opts ...WrapperOption) *httpWrapper\n</code></pre> <p>CreateHttpWrapper creates a new HTTP wrapper instance with optional configuration. The wrapper can be configured with custom headers, anti-bot detection features, and other options through functional options.</p> <p>By default, the wrapper uses:</p> <ul> <li>Default AntiGinx user agent</li> <li>30-second timeout</li> <li>Standard HTTP transport</li> </ul> <p>When anti-bot detection is enabled, it additionally configures:</p> <ul> <li>Browser-like TLS configuration</li> <li>HTTP/2 support</li> <li>Cookie jar for session management</li> <li>Connection pooling</li> </ul> <p>Parameters:</p> <ul> <li>opts: Variable number of WrapperOption functions for configuration</li> </ul> <p>Returns:</p> <ul> <li>*httpWrapper: Configured HTTP wrapper ready for use</li> </ul> <p>Example:</p> <pre><code>// Basic wrapper\nwrapper := CreateHttpWrapper()\n\n// Wrapper with custom headers\nwrapper := CreateHttpWrapper(WithHeaders(map[string]string{\n    \"Authorization\": \"Bearer token\",\n}))\n\n// Wrapper with stealth mode\nwrapper := CreateHttpWrapper(WithAntiBotDetection(\"advanced\"))\n</code></pre> <p></p>"},{"location":"App/HTTP/#func-httpwrapper-get","title":"func (*httpWrapper) Get","text":"<pre><code>func (hw *httpWrapper) Get(url string, opts ...WrapperOption) *http.Response\n</code></pre> <p>Get performs an HTTP GET request with built-in bot protection detection and Error handling. This method implements comprehensive security scanning capabilities including detection of Cloudflare, CAPTCHA, and various bot protection mechanisms.</p> <p>The method supports per-request configuration overrides and includes:</p> <ul> <li>Automatic bot protection detection (Cloudflare, Incapsula, DataDome, etc.)</li> <li>Human-like behavior simulation when anti-bot detection is enabled</li> <li>Structured Error handling with panic-based Error reporting</li> <li>Response body validation</li> </ul> <p>Error handling: The method panics with HttpError containing structured Error information:</p> <ul> <li>Code 100: Request creation failed</li> <li>Code 101: Network Error (DNS, timeout, connection)</li> <li>Code 102: Non-200 HTTP status Code</li> <li>Code 200: Response body reading Error</li> <li>Code 300: Bot protection detected (only in strict mode)</li> </ul> <p>Bot protection detection includes:</p> <ul> <li>Header-based: Cloudflare Server, CF-RAY, CF-Cache-Status, CF-CHL-BCODE</li> <li>Service detection: Incapsula, Distil Networks, PerimeterX, DataDome, Reblaze, Radware</li> <li>Content-based: CAPTCHA, challenge pages, access denied messages, JavaScript requirements</li> </ul> <p>Parameters:</p> <ul> <li>Url: Target URL to request</li> <li>opts: Optional per-request configuration overrides</li> </ul> <p>Returns:</p> <ul> <li>*http.Response: HTTP response object (only if successful and no bot protection detected)</li> </ul> <p>Panics:</p> <ul> <li>HttpError: On any Error condition with detailed Error information</li> </ul> <p>Example:</p> <pre><code>wrapper := CreateHttpWrapper()\nresponse := wrapper.Get(\"https://example.com\")\nfmt.Printf(\"Status: %s\\n\", response.Status)\n\n// With per-request options\nresponse := wrapper.Get(\"https://api.example.com\", WithHeaders(map[string]string{\n    \"Accept\": \"application/json\",\n}))\n</code></pre> <p></p>"},{"location":"App/HTTP/#type-httpwrapperconfig","title":"type httpWrapperConfig","text":"<p>httpWrapperConfig holds the configuration for the HTTP wrapper including custom headers and anti-bot detection settings. This structure is modified by WrapperOption functions to customize client behavior.</p> <pre><code>type httpWrapperConfig struct {\n    headers          map[string]string // Custom HTTP headers to be sent with requests\n    antiBotDetection bool              // Enable anti-bot detection bypass features\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"App/Helpers/","title":"Helpers","text":""},{"location":"App/Helpers/#helpers","title":"helpers","text":"<pre><code>import \"Engine-AntiGinx/App/Helpers\"\n</code></pre> <p>Package helpers provides utility functions for common operations throughout the Engine-AntiGinx application. This file contains mathematical utility functions for numeric operations.</p> <p>Package helpers provides utility functions for common operations throughout the Engine-AntiGinx application. It includes string manipulation utilities such as case-insensitive substring matching, duplicate removal, and other helper functions for data processing.</p> <p>Package Runner provides the TargetFormatter component for intelligent URL formatting based on the tests being executed. This file contains logic for automatically selecting the appropriate protocol (HTTP/HTTPS) based on test requirements.</p>"},{"location":"App/Helpers/#index","title":"Index","text":"<ul> <li>func AnyStringInSlice(slice []string, items []string) bool</li> <li>func CheckParameters(givenParams []*types.CommandParameter) *Errors.Error</li> <li>func ContainsAnySubstring(s string, subs []string) bool</li> <li>func DeserializeTests(bytes []byte) (*types.TestJson, *Errors.Error)</li> <li>func MinInt(a, b int) int</li> <li>func RemoveDuplicates(slice []string) []string</li> <li>func StringInSlice(slice []string, item string) bool</li> <li>func checkArgs(args []string, givenArgs []string) *Errors.Error</li> <li>type FileReader</li> <li>type OSFileReader</li> <li>func CreateFileReader() *OSFileReader</li> <li>func (osf *OSFileReader) ReadFileW(filename string) ([]byte, error)</li> <li>type targetFormatter</li> <li>func InitializeTargetFormatter() *targetFormatter</li> <li>func (t *targetFormatter) Format(target string, params []string) *string</li> <li>func (t *targetFormatter) containsParam(params []string, token string) bool</li> </ul>"},{"location":"App/Helpers/#func-anystringinslice","title":"func AnyStringInSlice","text":"<pre><code>func AnyStringInSlice(slice []string, items []string) bool\n</code></pre> <p>AnyStringInSlice checks if a string slice contains any of the specified items. This extends the StringInSlice function to check for multiple potential matches.</p> <p>Parameters:</p> <ul> <li>slice: The slice of strings to search in</li> <li>items: The slice of strings to search for</li> </ul> <p>Returns:</p> <ul> <li>bool: true if any item is found in the slice, false otherwise</li> </ul> <p>Example:</p> <pre><code>allowed := []string{\"GET\", \"POST\", \"PUT\"}\nmethods := []string{\"GET\", \"DELETE\"}\nhasValid := AnyStringInSlice(allowed, methods)  // returns true (GET is found)\n</code></pre> <p></p>"},{"location":"App/Helpers/#func-checkparameters","title":"func CheckParameters","text":"<pre><code>func CheckParameters(givenParams []*types.CommandParameter) *Errors.Error\n</code></pre> <p>CheckParameters iterates through the provided parameters and validates them against the global Params whitelist.</p> <p>It performs several checks:</p> <ul> <li>Checks for nil references.</li> <li>Verifies if the parameter name exists in the whitelist.</li> <li>Validates argument counts (min/max constraints).</li> <li>Applies default values for optional parameters if arguments are missing.</li> <li>Delegates specific argument validation to checkArgs.</li> </ul> <p></p>"},{"location":"App/Helpers/#func-containsanysubstring","title":"func ContainsAnySubstring","text":"<pre><code>func ContainsAnySubstring(s string, subs []string) bool\n</code></pre> <p>ContainsAnySubstring performs a case-insensitive search to determine if any of the provided substrings exist within the target string. This is particularly useful for detecting keywords or patterns in HTTP responses, such as bot protection indicators or security challenges.</p> <p>The function converts both the target string and all substrings to lowercase before comparison, ensuring consistent matching regardless of character casing.</p> <p>Parameters:</p> <ul> <li>s: The target string to search within</li> <li>subs: A slice of substrings to search for</li> </ul> <p>Returns:</p> <ul> <li>bool: true if any substring is found in the target string, false otherwise</li> </ul> <p>Example:</p> <pre><code>keywords := []string{\"cloudflare\", \"captcha\", \"challenge\"}\nbody := \"Please complete the Cloudflare Challenge to continue\"\nif ContainsAnySubstring(body, keywords) {\n    fmt.Println(\"Bot protection detected\")\n}\n</code></pre> <p></p>"},{"location":"App/Helpers/#func-deserializetests","title":"func DeserializeTests","text":"<pre><code>func DeserializeTests(bytes []byte) (*types.TestJson, *Errors.Error)\n</code></pre>"},{"location":"App/Helpers/#func-minint","title":"func MinInt","text":"<pre><code>func MinInt(a, b int) int\n</code></pre> <p>MinInt returns the smaller of two integers. This is a simple utility function for numeric comparison.</p> <p>Parameters:</p> <ul> <li>a: First integer</li> <li>b: Second integer</li> </ul> <p>Returns:</p> <ul> <li>int: The smaller of the two integers</li> </ul> <p>Example:</p> <pre><code>result := MinInt(5, 3)  // returns 3\nresult := MinInt(10, 15)  // returns 10\n</code></pre> <p></p>"},{"location":"App/Helpers/#func-removeduplicates","title":"func RemoveDuplicates","text":"<pre><code>func RemoveDuplicates(slice []string) []string\n</code></pre> <p>RemoveDuplicates removes duplicate strings from a slice while preserving the original order of first occurrence. It uses a map-based approach for efficient O(n) performance.</p> <p>This function is useful for deduplicating lists of test IDs, HTTP methods, or any other string collections where uniqueness is required.</p> <p>Parameters:</p> <ul> <li>slice: The input slice of strings that may contain duplicates</li> </ul> <p>Returns:</p> <ul> <li>[]string: A new slice containing only unique strings in their order of first appearance</li> </ul> <p>Example:</p> <pre><code>methods := []string{\"GET\", \"POST\", \"GET\", \"OPTIONS\", \"POST\"}\nunique := RemoveDuplicates(methods)\n// Result: [\"GET\", \"POST\", \"OPTIONS\"]\n</code></pre> <p></p>"},{"location":"App/Helpers/#func-stringinslice","title":"func StringInSlice","text":"<pre><code>func StringInSlice(slice []string, item string) bool\n</code></pre> <p>StringInSlice checks if a string slice contains a specific item. This is a basic utility function for slice membership testing.</p> <p>Parameters:</p> <ul> <li>slice: The slice of strings to search in</li> <li>item: The string to search for</li> </ul> <p>Returns:</p> <ul> <li>bool: true if item is found in the slice, false otherwise</li> </ul> <p>Example:</p> <pre><code>allowed := []string{\"GET\", \"POST\", \"PUT\"}\nisValid := StringInSlice(allowed, \"GET\")  // returns true\nisValid := StringInSlice(allowed, \"INVALID\")  // returns false\n</code></pre> <p></p>"},{"location":"App/Helpers/#func-checkargs","title":"func checkArgs","text":"<pre><code>func checkArgs(args []string, givenArgs []string) *Errors.Error\n</code></pre> <p>checkArgs verifies that the given arguments are allowed for a specific parameter. It checks if the arguments exist in the 'args' whitelist and detects duplicates.</p> <p>Return error if:</p> <ul> <li>An argument is not in the whitelist (Error 106).</li> <li>An argument appears more than once (Error 107).</li> </ul> <p></p>"},{"location":"App/Helpers/#type-filereader","title":"type FileReader","text":"<pre><code>type FileReader interface {\n    ReadFileW(filename string) ([]byte, error)\n}\n</code></pre>"},{"location":"App/Helpers/#type-osfilereader","title":"type OSFileReader","text":"<pre><code>type OSFileReader struct{}\n</code></pre>"},{"location":"App/Helpers/#func-createfilereader","title":"func CreateFileReader","text":"<pre><code>func CreateFileReader() *OSFileReader\n</code></pre>"},{"location":"App/Helpers/#func-osfilereader-readfilew","title":"func (*OSFileReader) ReadFileW","text":"<pre><code>func (osf *OSFileReader) ReadFileW(filename string) ([]byte, error)\n</code></pre>"},{"location":"App/Helpers/#type-targetformatter","title":"type targetFormatter","text":"<p>targetFormatter is responsible for formatting target URLs by intelligently adding appropriate protocol prefixes (http:// or https://) based on the tests being executed.</p> <p>The formatter implements smart protocol selection:</p> <ul> <li>Uses HTTP protocol when testing HTTP-specific vulnerabilities (https, hsts tests)</li> <li>Uses HTTPS protocol for all other tests by default</li> <li>Validates that user hasn't already specified a protocol</li> </ul> <p>This ensures tests can properly assess protocol-level security issues without automatic browser redirects interfering with the analysis.</p> <pre><code>type targetFormatter struct{}\n</code></pre> <p></p>"},{"location":"App/Helpers/#func-initializetargetformatter","title":"func InitializeTargetFormatter","text":"<pre><code>func InitializeTargetFormatter() *targetFormatter\n</code></pre> <p>InitializeTargetFormatter creates a new instance of targetFormatter ready to format target URLs. This factory function provides the entry point for creating a formatter that intelligently selects protocols based on test requirements.</p> <p>The formatter is stateless and can be reused for multiple formatting operations if needed, though typically only one instance is created per test run.</p> <p>Returns:</p> <ul> <li>*targetFormatter: A new formatter instance ready to call Format()</li> </ul> <p>Example:</p> <pre><code>formatter := InitializeTargetFormatter()\ntargetURL := formatter.Format(\"example.com\", []string{\"https\", \"hsts\"})\n// Returns: \"http://example.com\" (HTTP for protocol testing)\n</code></pre> <p></p>"},{"location":"App/Helpers/#func-targetformatter-format","title":"func (*targetFormatter) Format","text":"<pre><code>func (t *targetFormatter) Format(target string, params []string) *string\n</code></pre> <p>Format constructs a properly formatted target URL by adding the appropriate protocol prefix based on the tests being executed. It implements intelligent protocol selection to ensure tests can properly assess security configurations.</p> <p>Protocol selection logic:</p> <ul> <li> <p>HTTP (http://): Used when \"https\" or \"hsts\" tests are included Rationale: These tests specifically check for HTTP\u2192HTTPS redirects and HSTS headers, so starting with HTTP is necessary to observe the security behavior</p> </li> <li> <p>HTTPS (https://): Used for all other test combinations (default) Rationale: Most security tests should analyze the secure connection</p> </li> </ul> <p>Validation:</p> <ul> <li>Panics if target already contains \"http://\" or \"https://\" prefix Rationale: User should provide bare domain/hostname to allow automatic protocol selection</li> </ul> <p>Performance optimization:</p> <ul> <li>Uses strings.Builder with pre-allocated capacity for efficient string construction</li> <li>Grows buffer to avoid reallocations: len(target) + len(\"https://\")</li> </ul> <p>Parameters:</p> <ul> <li>target: Bare domain or hostname without protocol (e.g., \"example.com\", \"api.example.com\")</li> <li>params: List of test IDs to be executed (e.g., [\"https\", \"hsts\", \"csp\"])</li> </ul> <p>Returns:</p> <ul> <li>*string: Pointer to formatted URL with appropriate protocol prefix</li> </ul> <p>Panics:</p> <ul> <li>Errors.Error with code 100: If target already contains protocol prefix</li> </ul> <p>Examples:</p> <pre><code>formatter := InitializeTargetFormatter()\n\n// HTTPS test requires HTTP to check redirect behavior\nurl1 := formatter.Format(\"example.com\", []string{\"https\", \"csp\"})\n// Returns: \"http://example.com\"\n\n// HSTS test requires HTTP to check HSTS header\nurl2 := formatter.Format(\"example.com\", []string{\"hsts\"})\n// Returns: \"http://example.com\"\n\n// Other tests default to HTTPS\nurl3 := formatter.Format(\"example.com\", []string{\"csp\", \"xFrame\"})\n// Returns: \"https://example.com\"\n\n// Invalid: protocol already specified\nurl4 := formatter.Format(\"https://example.com\", []string{\"https\"})\n// Panics with error code 100\n</code></pre> <p></p>"},{"location":"App/Helpers/#func-targetformatter-containsparam","title":"func (*targetFormatter) containsParam","text":"<pre><code>func (t *targetFormatter) containsParam(params []string, token string) bool\n</code></pre> <p>containsParam is a helper function that performs a linear search to determine if a specific test ID (token) exists in the list of tests to be executed. This function is used internally by Format to implement protocol selection logic.</p> <p>The function uses simple iteration with O(n) time complexity, which is acceptable given that the params slice is typically small (usually 1-10 test IDs).</p> <p>Parameters:</p> <ul> <li>params: Slice of test IDs to search through</li> <li>token: The test ID to search for (e.g., \"https\", \"hsts\")</li> </ul> <p>Returns:</p> <ul> <li>bool: true if token is found in params, false otherwise</li> </ul> <p>Example:</p> <pre><code>formatter := &amp;targetFormatter{}\ntests := []string{\"https\", \"hsts\", \"csp\"}\n\nfound1 := formatter.containsParam(tests, \"https\")  // returns true\nfound2 := formatter.containsParam(tests, \"xFrame\") // returns false\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"App/Registry/","title":"Registry","text":""},{"location":"App/Registry/#registry","title":"Registry","text":"<pre><code>import \"Engine-AntiGinx/App/Registry\"\n</code></pre> <p>Package Registry provides a thread-safe, centralized registry system for managing security test implementations. It acts as a repository for all available ResponseTest instances, enabling dynamic test retrieval and execution throughout the application.</p> <p>The registry automatically initializes with default tests during package initialization and enforces uniqueness of test IDs to prevent conflicts. All tests are indexed by their string identifiers for fast O(1) lookup operations.</p> <p>Error codes:</p> <ul> <li>100: Duplicate test ID detected during registration</li> </ul>"},{"location":"App/Registry/#index","title":"Index","text":"<ul> <li>Variables</li> <li>func GetTest(testId string) (*Tests.ResponseTest, bool)</li> <li>func init()</li> <li>func registerTest(t *Tests.ResponseTest)</li> </ul>"},{"location":"App/Registry/#variables","title":"Variables","text":"<p>tests is the internal central storage for all registered response tests, indexed by their unique string ID. This map provides O(1) lookup performance for test retrieval operations.</p> <p>The map is populated during package initialization via the init() function and should not be modified directly outside of the registerTest function.</p> <pre><code>var tests = make(map[string]*Tests.ResponseTest)\n</code></pre> <p></p>"},{"location":"App/Registry/#func-gettest","title":"func GetTest","text":"<pre><code>func GetTest(testId string) (*Tests.ResponseTest, bool)\n</code></pre> <p>GetTest retrieves a specific ResponseTest from the registry by its unique identifier. This is the primary method for accessing registered tests and provides thread-safe read access to the registry.</p> <p>The function performs an O(1) map lookup and returns both the test instance and a boolean indicating whether the test was found. This pattern allows callers to distinguish between a missing test and other error conditions.</p> <p>Parameters:</p> <ul> <li>testId: The unique string identifier of the test to retrieve (e.g., \"https-protocol-check\", \"hsts-check\")</li> </ul> <p>Returns:</p> <ul> <li>*Tests.ResponseTest: Pointer to the test instance if found, nil otherwise</li> <li>bool: true if the test exists in the registry, false if not found</li> </ul> <p>Example:</p> <pre><code>test, exists := Registry.GetTest(\"https-protocol-check\")\nif !exists {\n    log.Printf(\"Test not found: https-protocol-check\")\n    return\n}\nresult := test.Run(params)\n</code></pre> <p></p>"},{"location":"App/Registry/#func-init","title":"func init","text":"<pre><code>func init()\n</code></pre> <p>init automatically registers default security tests when the Registry package is initialized. This function runs once before main() and ensures all standard tests are available for immediate use throughout the application lifecycle.</p> <p>Currently registered tests:</p> <ul> <li>HTTPSTest: Verifies HTTPS protocol usage</li> <li>HSTSTest: Checks HTTP Strict Transport Security headers</li> <li>ServerHeaderTest: Analyzes server header information</li> <li>CSPTest: Analyzes Content Security Policy configuration for XSS and injection protection</li> <li>CookieSecurityTest: Analyzes cookie security attributes and session management</li> <li>JSObfuscationTest: Detects obfuscated JavaScript code indicating potential security threats</li> <li>XFrameTest: Analyzes X-Frame-Options and CSP frame-ancestors for clickjacking protection</li> <li>ReferrerPolicyTest: Analyzes Referrer-Policy header for privacy and information leakage protection</li> <li>PermissionsPolicyTest: Analyzes Permissions-Policy header for browser feature access control</li> <li>XContentTypeOptionsTest: Analyzes X-Content-Type-Options header for MIME sniffing protection</li> <li>CrossOriginTest: Analyzes Cross-Origin security headers (COEP, CORP, COOP) for cross-origin attack protection</li> </ul> <p>Additional tests can be registered by adding registerTest calls in this function.</p> <p></p>"},{"location":"App/Registry/#func-registertest","title":"func registerTest","text":"<pre><code>func registerTest(t *Tests.ResponseTest)\n</code></pre> <p>registerTest adds a new test instance to the internal registry with strict ID uniqueness enforcement. This function is intended for internal use during package initialization via the init() function.</p> <p>The function performs validation to ensure no duplicate test IDs are registered, which could cause conflicts in test execution. If a duplicate is detected, it triggers a panic with detailed error information.</p> <p>Parameters:</p> <ul> <li>t: Pointer to the ResponseTest instance to register</li> </ul> <p>Panics:</p> <ul> <li>error.Error with code 100: If a test with the same ID already exists in the registry</li> </ul> <p>Example:</p> <pre><code>func init() {\n    registerTest(Tests.NewCustomTest())\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"App/Reporter/","title":"Reporter","text":""},{"location":"App/Reporter/#reporter","title":"Reporter","text":"<pre><code>import \"Engine-AntiGinx/App/Reporter\"\n</code></pre> <p>Package Reporter provides multiple reporting implementations for test results. This file contains the CLI reporter which outputs formatted test results directly to the console (stdout) for local debugging and interactive usage.</p> <p>The CLI reporter is used when no backend URL is configured or when running the scanner in standalone/development mode. It provides human-readable output with visual formatting including ASCII art banner and result separators.</p> <p>Package Reporter provides the core interface for test result reporting implementations. This file defines the Reporter interface that must be implemented by all reporter types, enabling polymorphic handling of different reporting strategies (CLI, HTTP backend, etc.).</p> <p>Package Reporter provides asynchronous test result reporting functionality using the producer-consumer pattern. It consumes TestResult objects from a channel and forwards them to an external backend service via HTTP POST requests with intelligent retry logic.</p> <p>The reporter implements:</p> <ul> <li>Non-blocking retry mechanism with exponential backoff</li> <li>Graceful shutdown with no data loss</li> <li>Error classification (retryable vs. fatal errors)</li> <li>Concurrent processing of results and retries</li> <li>Configurable retry limits and timeouts</li> </ul> <p>Error codes:</p> <ul> <li>100: JSON marshaling error (not retryable)</li> <li>101: HTTP request creation error (not retryable)</li> <li>102: Network error (retryable)</li> <li>103: HTTP status error (retryable for 5xx, not retryable for 4xx)</li> </ul>"},{"location":"App/Reporter/#index","title":"Index","text":"<ul> <li>Variables</li> <li>func printTestResult(result Tests.TestResult)</li> <li>type ConcreteResolver</li> <li>func NewResolver() *ConcreteResolver</li> <li>func (r *ConcreteResolver) Resolve(ch chan strategy.ResultWrapper, taskId string, target string, clientTimeOut int, retryDelay int, strategies []strategy.TestStrategy) Reporter</li> <li>func (r *ConcreteResolver) checkStrategies(strategies []strategy.TestStrategy) strategy.ReporterType</li> <li>type Reporter</li> <li>type Resolver</li> <li>type backendReporter</li> <li>func InitializeBackendReporter(channel chan strategy.ResultWrapper, backendURL string, testId string, target string, clientTimeOut int, retryDelay int) *backendReporter</li> <li>func (b *backendReporter) StartListening() \\&lt;-chan int</li> <li>func (b *backendReporter) handleRetryLogic(response *http.Response) *Errors.Error</li> <li>func (b *backendReporter) prepareReqWithErrHandling(result Tests.TestResultWrapper) (*http.Request, *Errors.Error)</li> <li>func (b *backendReporter) sendLastWithFlag(result Tests.TestResultWrapper, failedUploads *int)</li> <li>func (b *backendReporter) sendToBackend(result Tests.TestResultWrapper) error</li> <li>func (b *backendReporter) tryToSendOrEnqueue(result strategy.ResultWrapper, attNumber int, retryChan chan retryResult, retryWg *sync.WaitGroup, failedUploads *int)</li> <li>type cliReporter</li> <li>func InitializeCliReporter(channel chan strategy.ResultWrapper) *cliReporter</li> <li>func (c *cliReporter) StartListening() \\&lt;-chan int</li> <li>type helpReporter</li> <li>func NewHelpReporter(resultChan chan strategy.ResultWrapper) *helpReporter</li> <li>func (hr *helpReporter) StartListening() \\&lt;-chan int</li> <li>func (hr *helpReporter) printHelpInstruction(helpInstruction strategy.HelpStrategyResult)</li> <li>type retryResult</li> </ul>"},{"location":"App/Reporter/#variables","title":"Variables","text":"<p>banner is the ASCII art logo displayed at the start of CLI reporting. It identifies the application as \"ANTIGINX ENGINE\" and is printed once when the reporter starts listening for results.</p> <pre><code>var banner string = `\n    _    _   _ _____ ___ ____ ___ _   _ _  __\n   / \\  | \\ | |_   _|_ _/ ___|_ _| \\ | \\ \\/ /\n  / _ \\ |  \\| | | |  | | |  _ | ||  \\| |\\  / \n / ___ \\| |\\  | | |  | | |_| || || |\\  |/  \\ \n/_/   \\_\\_| \\_| |_| |___\\____|___|_| \\_/_/\\_\\\n _____ _   _  ____ ___ _   _ _____ \n| ____| \\ | |/ ___|_ _| \\ | | ____|\n|  _| |  \\| | |  _ | ||  \\| |  _|  \n| |___| |\\  | |_| || || |\\  | |___ \n|_____|_| \\_|\\____|___|_| \\_|_____|\n`\n</code></pre> <p></p> <pre><code>var helpBanner = `\n    _    _   _ _____ ___ ____ ___ _   _ _  __   _   _ _____ _     ____  \n   / \\  | \\ | |_   _|_ _/ ___|_ _| \\ | \\ \\/ /  | | | | ____| |   |  _ \\ \n  / _ \\ |  \\| | | |  | | |  _ | ||  \\| |\\  /   | |_| |  _| | |   | |_) |\n / ___ \\| |\\  | | |  | | |_| || || |\\  |/  \\   |  _  | |___| |___|  __/ \n/_/   \\_\\_| \\_| |_| |___\\____|___|_| \\_/_/\\_\\  |_| |_|_____|_____|_|  \n`\n</code></pre> <p>separator is a visual delimiter printed between test results in the console output. It helps distinguish individual test results and improves readability of the output when multiple tests are executed.</p> <pre><code>var separator string = `---------------------------------------------`\n</code></pre> <p></p>"},{"location":"App/Reporter/#func-printtestresult","title":"func printTestResult","text":"<pre><code>func printTestResult(result Tests.TestResult)\n</code></pre> <p>printTestResult formats and prints a single test result to stdout with structured formatting. This helper function provides consistent, human-readable output for all test results.</p> <p>Output format:</p> <ul> <li>Test name: [string] - The human-readable name of the test</li> <li>Certainty: [0-100] - Confidence percentage in the result</li> <li>Threat level: [0-5] - Security threat classification</li> <li>0 = None (no issues)</li> <li>1 = Info (informational)</li> <li>2 = Low (minor issues)</li> <li>3 = Medium (moderate concern)</li> <li>4 = High (serious vulnerability)</li> <li>5 = Critical (severe vulnerability)</li> <li>Description: [string] - Detailed explanation of the finding</li> <li>Separator line for visual distinction</li> </ul> <p>The function is called internally by StartListening for each result received from the result channel.</p> <p>Parameters:</p> <ul> <li>result: The TestResult structure containing test execution data</li> </ul> <p>Example output:</p> <pre><code>Test name: HTTPS Protocol Verification\nCertainty: 100\nThreat level: 4\nDescription: Connection uses insecure HTTP protocol - data is transmitted in plaintext\n---------------------------------------------\n</code></pre> <p></p>"},{"location":"App/Reporter/#type-concreteresolver","title":"type ConcreteResolver","text":"<pre><code>type ConcreteResolver struct{}\n</code></pre>"},{"location":"App/Reporter/#func-newresolver","title":"func NewResolver","text":"<pre><code>func NewResolver() *ConcreteResolver\n</code></pre> <p>NewResolver initializes and returns a new instance of the ConcreteResolver struct.</p> <p>Returns:</p> <ul> <li>*ConcreteResolver: A pointer to the newly created resolver instance</li> </ul> <p></p>"},{"location":"App/Reporter/#func-concreteresolver-resolve","title":"func (*ConcreteResolver) Resolve","text":"<pre><code>func (r *ConcreteResolver) Resolve(ch chan strategy.ResultWrapper, taskId string, target string, clientTimeOut int, retryDelay int, strategies []strategy.TestStrategy) Reporter\n</code></pre> <p>Resolve determines and initializes the appropriate Reporter implementation based on the provided strategies and environment configuration.</p> <p>The resolution logic follows this priority order: 1. If strategies prefer a HelpReporter, it returns a new HelpReporter. 2. If the \"BACK_URL\" environment variable is set, it returns an initialized BackendReporter. 3. Otherwise, it defaults to returning an InitializeCliReporter.</p> <p>Parameters:</p> <ul> <li>ch: The channel used for transmitting strategy result wrappers</li> <li>taskId: The unique identifier for the current task</li> <li>target: The target endpoint or system being tested</li> <li>clientTimeOut: The timeout duration for the client in seconds (or ms, depending on impl)</li> <li>retryDelay: The delay duration between retries</li> <li>strategies: A slice of test strategies to be validated and used for reporting decisions</li> </ul> <p>Returns:</p> <ul> <li>Reporter: An interface satisfying the Reporter contract (Help, Backend, or CLI)</li> </ul> <p></p>"},{"location":"App/Reporter/#func-concreteresolver-checkstrategies","title":"func (*ConcreteResolver) checkStrategies","text":"<pre><code>func (r *ConcreteResolver) checkStrategies(strategies []strategy.TestStrategy) strategy.ReporterType\n</code></pre> <p>checkStrategies validates that all provided strategies share the same preferred reporter type.</p> <p>This helper method iterates through the provided strategies to ensure consistency. It will panic if the strategy list is empty or if there is a conflict in the preferred reporter type between different strategies.</p> <p>Parameters:</p> <ul> <li>strategies: The list of strategies to validate</li> </ul> <p>Returns:</p> <ul> <li>strategy.ReporterType: The unified reporter type preferred by the strategies</li> </ul> <p></p>"},{"location":"App/Reporter/#type-reporter","title":"type Reporter","text":"<p>Reporter is the interface that defines the contract for all test result reporting implementations. It provides a unified abstraction for consuming test results from a channel and processing them according to the specific reporter's strategy.</p> <p>The interface enables the application to work with different reporting backends without coupling the test execution logic to specific output mechanisms. This allows for:</p> <ul> <li>Flexible output destinations (console, HTTP backend, file, etc.)</li> <li>Easy addition of new reporter types</li> <li>Testability through mock implementations</li> <li>Runtime selection of reporting strategy</li> </ul> <p>Current implementations:</p> <ul> <li>cliReporter: Outputs formatted results to stdout (console)</li> <li>backendReporter: Sends results to external HTTP backend with retry logic</li> </ul> <p>Expected behavior:</p> <ul> <li>StartListening() should spawn a goroutine for asynchronous processing</li> <li>The reporter should consume all results from its input channel</li> <li>Processing should continue until the input channel is closed</li> <li>The returned channel should signal completion and provide error/failure count</li> <li>Implementations should handle graceful shutdown without data loss</li> </ul> <p>Example usage:</p> <pre><code>// Create reporter based on configuration\nvar reporter Reporter\nif backendURL != \"\" {\n    reporter = InitializeBackendReporter(resultChan, backendURL)\n} else {\n    reporter = InitializeCliReporter(resultChan)\n}\n\n// Start processing\ndoneChan := reporter.StartListening()\n\n// Send results to reporter...\nfor _, result := range testResults {\n    resultChan &lt;- result\n}\nclose(resultChan)\n\n// Wait for completion\nfailureCount := &lt;-doneChan\nif failureCount &gt; 0 {\n    log.Printf(\"Warning: %d results failed to process\", failureCount)\n}\n</code></pre> <pre><code>type Reporter interface {\n    // StartListening initiates asynchronous processing of test results from the reporter's\n    // input channel. This method must be non-blocking and should spawn a goroutine for\n    // background processing.\n    //\n    // The method returns a receive-only channel that signals when all processing is complete.\n    // The integer value sent on this channel represents the count of failed operations:\n    //   - 0: All results processed successfully (or no failures possible, as in CLI reporter)\n    //   - &gt;0: Number of results that failed to process (e.g., failed HTTP uploads)\n    //\n    // Implementations must:\n    //   - Process all results until the input channel is closed\n    //   - Handle errors gracefully with appropriate retry logic if applicable\n    //   - Ensure no data loss during shutdown\n    //   - Send exactly one value to the returned channel before closing it\n    //\n    // Returns:\n    //   - &lt;-chan int: Completion signal channel with failure count\n    StartListening() &lt;-chan int\n}\n</code></pre> <p></p>"},{"location":"App/Reporter/#type-resolver","title":"type Resolver","text":"<p>Resolver defines the contract for determining and creating the appropriate Reporter instance based on the execution context and configuration.</p> <p>Implementations of this interface are responsible for analyzing the provided strategies and environment settings to decide which reporting mechanism (e.g., CLI, Backend, Help) should be used.</p> <pre><code>type Resolver interface {\n\n    // Resolve instantiates and returns a concrete Reporter implementation.\n    //\n    // It acts as a factory method that uses the provided strategies to determine\n    // the correct reporting type and initializes it with the necessary context.\n    //\n    // Parameters:\n    //  - ch: The channel used for transmitting result wrappers asynchronously\n    //  - taskId: The unique identifier for the current task\n    //  - target: The target endpoint or system string\n    //  - clientTimeOut: The timeout duration for the client\n    //  - retryDelay: The delay duration between retries\n    //  - strategies: A list of TestStrategy objects to derive the preferred reporter type\n    //\n    // Returns:\n    //  - Reporter: An initialized reporter interface ready to handle results\n    Resolve(ch chan strategy.ResultWrapper, taskId string,\n        target string, clientTimeOut int, retryDelay int, strategies []strategy.TestStrategy) Reporter\n}\n</code></pre> <p></p>"},{"location":"App/Reporter/#type-backendreporter","title":"type backendReporter","text":"<p>backendReporter handles the consumption of test results and forwards them to an external backend service via HTTP. It implements a robust producer-consumer pattern with a non-blocking retry mechanism for handling transient failures.</p> <p>The reporter processes results asynchronously in a separate goroutine and applies intelligent retry logic based on error types. Network errors and server errors (5xx) are retried, while client errors (4xx) and marshaling errors are not.</p> <p>Architecture:</p> <ul> <li>Main processing loop: Consumes from resultChannel</li> <li>Retry queue: Buffered channel for failed submissions</li> <li>Retry goroutines: Sleep-based backoff for rate limiting</li> </ul> <p>Fields:</p> <ul> <li>resultChannel: Input channel for test results from the Runner</li> <li>backendURL: Target HTTP endpoint for result submission</li> <li>testId: ID of test from RabbitMQ</li> <li>maxRetries: Maximum retry attempts for failed submissions (default: 2)</li> <li>httpClient: HTTP client with configured timeout (default: 5 seconds)</li> </ul> <pre><code>type backendReporter struct {\n    resultChannel chan strategy.ResultWrapper\n    backendURL    string\n    testId        string\n    target        string\n    maxRetries    int\n    retryDelay    int\n    httpClient    *http.Client\n}\n</code></pre> <p></p>"},{"location":"App/Reporter/#func-initializebackendreporter","title":"func InitializeBackendReporter","text":"<pre><code>func InitializeBackendReporter(channel chan strategy.ResultWrapper, backendURL string, testId string, target string, clientTimeOut int, retryDelay int) *backendReporter\n</code></pre> <p>InitializeBackendReporter creates and configures a new instance of backendReporter with sensible defaults for production use. The reporter is ready to start processing results immediately after initialization.</p> <p>Default configuration:</p> <ul> <li>HTTP timeout: 5 seconds</li> <li>Max retries: 2 attempts</li> <li>Retry delay: 2 seconds (hardcoded in tryToSendOrEnqueue)</li> </ul> <p>The reporter must be started by calling StartListening() to begin processing results.</p> <p>Parameters:</p> <ul> <li>channel: The input channel where test results are published by the Runner</li> <li>backendURL: The target HTTP endpoint for result submission (e.g., \"http://api.example.com/results\")</li> </ul> <p>Returns:</p> <ul> <li>*backendReporter: Configured reporter instance ready to start listening</li> </ul> <p>Example:</p> <pre><code>resultChan := make(chan Tests.TestResult, 10)\nreporter := InitializeBackendReporter(resultChan, \"http://api.example.com/results\")\ndoneChan := reporter.StartListening()\n// ... send results to resultChan ...\nclose(resultChan)\nfailedCount := &lt;-doneChan\nfmt.Printf(\"Processing complete. Failed uploads: %d\\n\", failedCount)\n</code></pre> <p></p>"},{"location":"App/Reporter/#func-backendreporter-startlistening","title":"func (*backendReporter) StartListening","text":"<pre><code>func (b *backendReporter) StartListening() &lt;-chan int\n</code></pre> <p>StartListening initiates the asynchronous background processing loop that consumes test results and forwards them to the backend service. This method spawns a goroutine that handles both new results and retry attempts concurrently.</p> <p>Processing architecture:</p> <p>The method uses a select statement to handle two input sources:</p> <ol> <li>resultChannel: New test results from the Runner</li> <li>retryChan: Failed results waiting for retry after backoff delay</li> </ol> <p>Graceful shutdown sequence:</p> <ol> <li>Producer closes resultChannel signaling no more results</li> <li>Reporter processes all remaining results in the channel</li> <li>Reporter waits for all sleeping retry goroutines (via retryWg)</li> <li>Reporter processes any new retries added by sleeping goroutines</li> <li>Reporter sends final failure count and exits</li> </ol> <p>This ensures zero data loss during shutdown - all results are either successfully submitted or counted as failures.</p> <p>Retry mechanism:</p> <ul> <li>Buffered retry channel (capacity: 10) prevents blocking</li> <li>WaitGroup tracks sleeping retry goroutines</li> <li>2-second delay between retry attempts</li> <li>Retryable errors are re-queued up to maxRetries limit</li> </ul> <p>Returns:</p> <ul> <li>\\&lt;-chan int: Read-only channel that receives the total count of failed uploads once all processing is complete (including retries)</li> </ul> <p>Example:</p> <pre><code>reporter := InitializeBackendReporter(resultChan, \"http://api.example.com/results\")\ndoneChan := reporter.StartListening()\n\n// Send results...\nfor _, result := range testResults {\n    resultChan &lt;- result\n}\nclose(resultChan)\n\n// Wait for completion\nfailedCount := &lt;-doneChan\nif failedCount &gt; 0 {\n    log.Printf(\"Warning: %d results failed to upload\", failedCount)\n}\n</code></pre> <p></p>"},{"location":"App/Reporter/#func-backendreporter-handleretrylogic","title":"func (*backendReporter) handleRetryLogic","text":"<pre><code>func (b *backendReporter) handleRetryLogic(response *http.Response) *Errors.Error\n</code></pre>"},{"location":"App/Reporter/#func-backendreporter-preparereqwitherrhandling","title":"func (*backendReporter) prepareReqWithErrHandling","text":"<pre><code>func (b *backendReporter) prepareReqWithErrHandling(result Tests.TestResultWrapper) (*http.Request, *Errors.Error)\n</code></pre>"},{"location":"App/Reporter/#func-backendreporter-sendlastwithflag","title":"func (*backendReporter) sendLastWithFlag","text":"<pre><code>func (b *backendReporter) sendLastWithFlag(result Tests.TestResultWrapper, failedUploads *int)\n</code></pre> <p>sendLastWithFlag sends a final request to the backend to signal that the engine has completed its work.</p> <p>This method sends an empty TestResult with EndFlag=true to the backend, indicating completion of all test processing. It handles both retryable and non-retryable errors: if the error is retryable, it waits 2 seconds and retries once more; otherwise, it increments the failedUploads counter.</p> <p>Parameters:</p> <ul> <li>result: The TestResultWrapper to send. Typically, this should be an empty result with EndFlag set to true.</li> <li>failedUploads: Pointer to an integer counter tracking the number of failed uploads. This will be incremented if the final request fails.</li> </ul> <p></p>"},{"location":"App/Reporter/#func-backendreporter-sendtobackend","title":"func (*backendReporter) sendToBackend","text":"<pre><code>func (b *backendReporter) sendToBackend(result Tests.TestResultWrapper) error\n</code></pre> <p>sendToBackend performs the actual HTTP POST request to the configured backend endpoint with comprehensive error handling and classification. This method executes the complete HTTP request lifecycle from marshaling to response validation.</p> <p>Request process:</p> <ol> <li>Marshal the TestResult to JSON</li> <li>Create HTTP POST request with JSON payload</li> <li>Set Content-Type header to application/json</li> <li>Execute request with configured timeout (default: 5 seconds)</li> <li>Validate response status code</li> </ol> <p>Error classification:</p> <ul> <li>Code 100 (JSON Marshal): Not retryable - indicates invalid test result structure</li> <li>Code 101 (Request Creation): Not retryable - indicates programming error</li> <li>Code 102 (Network Error): Retryable - transient network issues, DNS failures, timeouts</li> <li>Code 103 (HTTP Status): Conditional retry based on status code:</li> <li>200-299: Success, no error</li> <li>400, 401, 403: Not retryable (client errors, auth issues)</li> <li>404, 405, etc.: Not retryable (client errors)</li> <li>500-599: Retryable (server errors, temporary outages)</li> </ul> <p>The method returns structured Errors.Error objects that include the IsRetryable flag, allowing the retry logic to make intelligent decisions about whether to re-attempt the submission.</p> <p>Parameters:</p> <ul> <li>result: The TestResult to submit to the backend</li> </ul> <p>Returns:</p> <ul> <li>error: nil on success (HTTP 2xx), *Errors.Error with retry information on failure</li> </ul> <p>Example error handling:</p> <pre><code>err := reporter.sendToBackend(testResult)\nif err != nil {\n    var customErr *Errors.Error\n    if errors.As(err, &amp;customErr) &amp;&amp; customErr.IsRetryable {\n        // Retry logic\n    } else {\n        // Permanent failure\n    }\n}\n</code></pre> <p></p>"},{"location":"App/Reporter/#func-backendreporter-trytosendorenqueue","title":"func (*backendReporter) tryToSendOrEnqueue","text":"<pre><code>func (b *backendReporter) tryToSendOrEnqueue(result strategy.ResultWrapper, attNumber int, retryChan chan retryResult, retryWg *sync.WaitGroup, failedUploads *int)\n</code></pre> <p>tryToSendOrEnqueue attempts to send a test result to the backend and manages the retry workflow based on the outcome. This method implements the core retry logic with exponential backoff and retry limit enforcement.</p> <p>Workflow:</p> <ol> <li>Attempt to send the result via sendToBackend</li> <li>On success: return immediately</li> <li>On failure: check if error is retryable</li> <li>If retryable and under retry limit: spawn backoff goroutine</li> <li>If not retryable or limit exceeded: increment failure counter</li> </ol> <p>Retry behavior:</p> <ul> <li>Network errors (code 102): Retried</li> <li>Server errors 5xx (code 103): Retried</li> <li>Client errors 4xx (code 103): Not retried</li> <li>Marshaling errors (code 100): Not retried</li> <li>Request creation errors (code 101): Not retried</li> </ul> <p>The retry goroutine sleeps for 2 seconds before re-queuing the result, preventing rapid retry storms and giving the backend time to recover from transient issues.</p> <p>Parameters:</p> <ul> <li>result: The test result to submit</li> <li>attNumber: Current attempt number (0-based)</li> <li>retryChan: Channel for re-queuing failed results</li> <li>retryWg: WaitGroup for tracking sleeping retry goroutines</li> <li>failedUploads: Pointer to counter for permanent failures</li> </ul> <p></p>"},{"location":"App/Reporter/#type-clireporter","title":"type cliReporter","text":"<p>cliReporter is a console-based reporter implementation that outputs test results directly to standard output (stdout). It provides formatted, human-readable output for interactive use and local development.</p> <p>Unlike the backendReporter, this implementation does not perform HTTP requests or implement retry logic. It simply formats and prints results synchronously as they arrive on the result channel.</p> <p>The reporter is typically used in scenarios:</p> <ul> <li>Local development and debugging</li> <li>Standalone scanner execution without backend</li> <li>Manual security testing and verification</li> <li>CI/CD pipelines that need console output</li> </ul> <p>Fields:</p> <ul> <li>resultChannel: Receive-only channel for consuming test results</li> </ul> <pre><code>type cliReporter struct {\n    resultChannel &lt;-chan strategy.ResultWrapper\n}\n</code></pre> <p></p>"},{"location":"App/Reporter/#func-initializeclireporter","title":"func InitializeCliReporter","text":"<pre><code>func InitializeCliReporter(channel chan strategy.ResultWrapper) *cliReporter\n</code></pre> <p>InitializeCliReporter creates and returns a new instance of the CLI reporter configured to consume test results from the specified channel. The reporter is ready to start listening immediately after initialization.</p> <p>This factory function provides a simple way to create a CLI reporter for scenarios where HTTP backend reporting is not required or desired. It's commonly used for:</p> <ul> <li>Local development and testing</li> <li>Debugging security tests</li> <li>Standalone scanner execution</li> <li>Quick security assessments</li> </ul> <p>The reporter will format and print each result to stdout as it's received, providing immediate feedback during test execution.</p> <p>Parameters:</p> <ul> <li>channel: The input channel where test results are published by the Runner</li> </ul> <p>Returns:</p> <ul> <li>*cliReporter: Configured reporter instance ready to start listening</li> </ul> <p>Example:</p> <pre><code>resultChan := make(chan Tests.TestResult, 10)\nreporter := InitializeCliReporter(resultChan)\ndoneChan := reporter.StartListening()\n\n// Send test results...\nfor _, result := range testResults {\n    resultChan &lt;- result\n}\nclose(resultChan)\n\n// Wait for completion\n&lt;-doneChan\n</code></pre> <p></p>"},{"location":"App/Reporter/#func-clireporter-startlistening","title":"func (*cliReporter) StartListening","text":"<pre><code>func (c *cliReporter) StartListening() &lt;-chan int\n</code></pre> <p>StartListening begins the asynchronous process of consuming and printing test results to the console. This method spawns a goroutine that displays the application banner and then continuously processes results until the input channel is closed.</p> <p>Processing sequence:</p> <ol> <li>Print ASCII art banner to stdout</li> <li>Print \"TEST RESULT\" header</li> <li>Enter processing loop (range over resultChannel)</li> <li>For each result: call printTestResult to format and display</li> <li>When channel closes: send completion signal and exit</li> </ol> <p>Output format for each test:</p> <ul> <li>Test Name</li> <li>Certainty percentage (0-100)</li> <li>Threat Level (0-5: None, Info, Low, Medium, High, Critical)</li> <li>Description</li> <li>Visual separator line</li> </ul> <p>The method provides immediate visual feedback as tests complete, making it ideal for interactive use and debugging. Unlike the backend reporter, this implementation is synchronous (no retries) and has no failure modes - all results are printed.</p> <p>Returns:</p> <ul> <li>\\&lt;-chan int: Read-only channel that receives 0 when processing is complete (always 0 for CLI reporter as there are no upload failures)</li> </ul> <p>Example:</p> <pre><code>reporter := InitializeCliReporter(resultChan)\ndoneChan := reporter.StartListening()\n\n// Results are printed as they arrive...\n// Output:\n// [ASCII Banner]\n// TEST RESULT\n// Test name: HTTPS Protocol Verification\n// Certainty: 100\n// Threat level: 0\n// Description: Connection is secured with HTTPS protocol\n// ---------------------------------------------\n\n&lt;-doneChan  // Blocks until all results processed\n</code></pre> <p></p>"},{"location":"App/Reporter/#type-helpreporter","title":"type helpReporter","text":"<pre><code>type helpReporter struct {\n    resultChan chan strategy.ResultWrapper\n}\n</code></pre>"},{"location":"App/Reporter/#func-newhelpreporter","title":"func NewHelpReporter","text":"<pre><code>func NewHelpReporter(resultChan chan strategy.ResultWrapper) *helpReporter\n</code></pre>"},{"location":"App/Reporter/#func-helpreporter-startlistening","title":"func (*helpReporter) StartListening","text":"<pre><code>func (hr *helpReporter) StartListening() &lt;-chan int\n</code></pre>"},{"location":"App/Reporter/#func-helpreporter-printhelpinstruction","title":"func (*helpReporter) printHelpInstruction","text":"<pre><code>func (hr *helpReporter) printHelpInstruction(helpInstruction strategy.HelpStrategyResult)\n</code></pre>"},{"location":"App/Reporter/#type-retryresult","title":"type retryResult","text":"<p>retryResult is an internal wrapper structure used to track the state of a failed submission in the retry queue. It encapsulates both the original test result and metadata about the retry attempt to enforce retry limits and prevent infinite retry loops.</p> <p>Fields:</p> <ul> <li>result: The original TestResult that failed to submit</li> <li>attNum: Current attempt number (0-based, incremented with each retry)</li> </ul> <pre><code>type retryResult struct {\n    result strategy.ResultWrapper\n    attNum int\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"App/Runner/","title":"Runner","text":""},{"location":"App/Runner/#runner","title":"Runner","text":"<pre><code>import \"Engine-AntiGinx/App/Runner\"\n</code></pre> <p>Package Runner provides the central orchestration logic for the Engine-AntiGinx scanner. It coordinates all major components including parameter parsing, HTTP client configuration, test registry access, concurrent test execution, and result reporting.</p> <p>The Runner acts as the main controller that:</p> <ul> <li>Parses command-line parameters to determine which tests to run</li> <li>Loads target website content once and shares it across all tests</li> <li>Spawns concurrent goroutines for parallel test execution</li> <li>Manages result reporting through the Reporter interface</li> <li>Handles graceful shutdown and synchronization</li> </ul> <p>Architecture:</p> <ul> <li>Fan-out pattern: One HTTP response shared among multiple test workers</li> <li>Producer-consumer: Tests produce results, reporter consumes them</li> <li>Synchronization: WaitGroup for test completion, channel for reporter completion</li> </ul> <p>Error codes:</p> <ul> <li>100: No tests specified for execution (missing --tests parameter)</li> <li>201: Invalid test ID (test does not exist in Registry)</li> </ul>"},{"location":"App/Runner/#index","title":"Index","text":"<ul> <li>type jobRunner</li> <li>func CreateJobRunner() *jobRunner</li> <li>func (j *jobRunner) Orchestrate(execPlan *execution.Plan, repResolver Reporter.Resolver)</li> </ul>"},{"location":"App/Runner/#type-jobrunner","title":"type jobRunner","text":"<p>jobRunner is the central orchestrator responsible for coordinating the entire test execution lifecycle. It connects all major components of the application and manages their interactions.</p> <p>The runner implements the following workflow:</p> <ol> <li>Parameter parsing: Extracts test IDs and target URL from command-line arguments</li> <li>Reporter initialization: Selects CLI or backend reporter based on configuration</li> <li>Content loading: Fetches target website content once for efficiency</li> <li>Concurrent execution: Spawns goroutines for parallel test execution</li> <li>Result collection: Gathers test results via channel</li> <li>Graceful shutdown: Waits for all tests and reporting to complete</li> </ol> <p>The runner uses a fan-out concurrency pattern where a single HTTP response is shared among multiple test worker goroutines, enabling efficient parallel processing without redundant HTTP requests.</p> <pre><code>type jobRunner struct{}\n</code></pre> <p></p>"},{"location":"App/Runner/#func-createjobrunner","title":"func CreateJobRunner","text":"<pre><code>func CreateJobRunner() *jobRunner\n</code></pre> <p>CreateJobRunner initializes and returns a new instance of jobRunner ready to orchestrate test execution. This factory function provides the entry point for creating the main application controller.</p> <p>The returned runner is stateless and can be used to orchestrate multiple test execution sessions if needed, though typically only one instance is created per application run.</p> <p>Returns:</p> <ul> <li>*jobRunner: A new runner instance ready to call Orchestrate()</li> </ul> <p>Example:</p> <pre><code>runner := CreateJobRunner()\nrunner.Orchestrate(execPlan)\n</code></pre> <p></p>"},{"location":"App/Runner/#func-jobrunner-orchestrate","title":"func (*jobRunner) Orchestrate","text":"<pre><code>func (j *jobRunner) Orchestrate(execPlan *execution.Plan, repResolver Reporter.Resolver)\n</code></pre> <p>Orchestrate is the main execution method that coordinates all components to perform security testing. It validates the execution plan, configures the reporting infrastructure, executes strategies, and manages a graceful shutdown of the concurrency pipeline.</p> <p>Execution Workflow:</p> <ol> <li> <p>Plan Validation and Extraction: - Validates that the execution plan contains at least one strategy. - Extracts global flags (AntiBotFlag) and target information.</p> </li> <li> <p>Concurrency Infrastructure Setup: - Initializes a buffered result channel (capacity: 100) to decouple test execution from reporting. - Initializes a sync.WaitGroup to track the lifecycle of asynchronous strategies.</p> </li> <li> <p>Reporter Selection and Initialization: - Checks for the \"BACK_URL\" environment variable. - If BACK_URL exists, validates TaskId and initializes the BackendReporter. - Otherwise, falls back to the CliReporter for local terminal output.</p> </li> <li> <p>Reporting Pipeline Activation: - Starts the reporter's listener goroutine. - Obtains a doneChannel to synchronize the final shutdown sequence.</p> </li> <li> <p>Concurrent Strategy Execution (Fan-out): - Iterates through the ordered list of strategies in the Plan. - Triggers the Execute method for each strategy, passing the specific context, result channel, and synchronization primitives.</p> </li> <li> <p>Graceful Shutdown: - Blocks until all strategy-level goroutines signal completion (wg.Wait). - Closes the result channel to signal the reporter that no more data is coming. - Blocks until the reporter processes remaining results and closes the doneChannel. - Reports any failed uploads (e.g., network issues during backend reporting) to Stderr.</p> </li> </ol> <p>Concurrency Architecture:</p> <ul> <li>Producer-Consumer: Test strategies (producers) feed results into a shared buffered channel.</li> <li>Fan-out: A single execution plan triggers multiple independent strategy executions.</li> <li>Synchronization: Uses a combination of WaitGroups for worker tracking and channels for state signaling.</li> </ul> <p>Environment Variables:</p> <ul> <li>BACK_URL: If set, the orchestrator switches from CLI output to remote API reporting.</li> </ul> <p>Parameters:</p> <ul> <li>execPlan: A pre-formatted execution plan containing the target, taskId, and strategies.</li> </ul> <p>Panics:</p> <ul> <li>error.Error (Code 100): No tests found in the execution plan.</li> <li>error.Error (Code 101): BACK_URL is set, but TaskId is missing or empty.</li> </ul> <p>Example:</p> <pre><code>runner := CreateJobRunner()\nplan := &amp;execution.Plan{\n    Target: \"example.com\",\n    Strategies: []strategy.TestStrategy{headerStrat},\n    TaskId: \"uuid-123\",\n}\nrunner.Orchestrate(plan)\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"App/Tests/","title":"Tests","text":""},{"location":"App/Tests/#tests","title":"Tests","text":"<pre><code>import \"Engine-AntiGinx/App/Tests\"\n</code></pre> <p>Package Tests provides security test implementations for HTTP response analysis. This file contains the CSP (Content Security Policy) test that analyzes Content-Security-Policy header configuration to assess protection against XSS, data injection, and other web vulnerabilities.</p> <p>Package Tests provides security test implementations for HTTP response analysis. This file contains the Cookie Security test that analyzes Set-Cookie headers for security best practices including HttpOnly, Secure, SameSite attributes, expiration times, and potential session fixation vulnerabilities.</p> <p>Package Tests provides security test implementations for HTTP response analysis. This file contains the Cross-Origin security headers test that analyzes Cross-Origin-Embedder-Policy (COEP), Cross-Origin-Resource-Policy (CORP), and Cross-Origin-Opener-Policy (COOP) headers to assess protection against cross-origin attacks and isolation vulnerabilities.</p> <p>Package Tests provides security test implementations for HTTP response analysis. This file contains the HSTS (HTTP Strict Transport Security) test that checks for proper HSTS header configuration to prevent protocol downgrade attacks.</p> <p>Package Tests provides security testing functionality for Engine-AntiGinx.</p>"},{"location":"App/Tests/#httpstest-module","title":"HTTPSTest Module","text":"<p>This module implements HTTPS protocol verification to ensure secure communication channels. It validates whether websites enforce encrypted HTTPS connections instead of insecure HTTP, which is critical for protecting data in transit.</p> <p>Security Importance:</p> <p>HTTPS (HTTP Secure) uses TLS/SSL encryption to:</p> <ul> <li>Encrypt data transmission preventing eavesdropping</li> <li>Authenticate the server preventing man-in-the-middle attacks</li> <li>Ensure data integrity preventing tampering</li> <li>Meet compliance requirements (PCI DSS, GDPR, HIPAA)</li> </ul> <p>HTTP vs HTTPS:</p> <pre><code>HTTP:  No encryption, data sent in plaintext \u2192 High threat\nHTTPS: TLS/SSL encryption, secure transmission \u2192 No threat\n</code></pre> <p>Threat Assessment:</p> <ul> <li>ThreatLevel.None: Website uses HTTPS with proper encryption</li> <li>ThreatLevel.High: Website uses HTTP exposing data to interception</li> </ul> <p>This test is typically the first security check performed as it validates the fundamental security posture of a web application.</p> <p>Integration:</p> <p>This test is registered in the test registry and executed by the job runner during security scanning operations.</p> <p>Package Tests provides security test implementations for HTTP response analysis. This file contains the JavaScript Obfuscation test that detects obfuscated JavaScript code which may indicate malicious activity, code hiding, or security evasion techniques.</p> <p>Package Tests provides security test implementations for HTTP response analysis. This file contains the Permissions-Policy test that checks for proper browser feature access control configuration to prevent abuse of sensitive browser APIs.</p> <p>Package Tests provides security test implementations for HTTP response analysis. This file contains the Referrer-Policy test that checks for proper referrer information control configuration to prevent information leakage and protect user privacy.</p> <p>Package Tests provides security testing functionality for Engine-AntiGinx.</p>"},{"location":"App/Tests/#serverheadertest-module","title":"ServerHeaderTest Module","text":"<p>This module analyzes HTTP response headers to identify information disclosure vulnerabilities where servers expose technology stack details. Such exposure provides attackers with reconnaissance data useful for targeted attacks.</p> <p>Security Context:</p> <p>Information disclosure through HTTP headers violates the principle of security through obscurity and assists attackers in:</p> <ul> <li>Identifying specific software versions with known vulnerabilities</li> <li>Crafting targeted exploits for detected technologies</li> <li>Mapping the technology stack for attack surface analysis</li> <li>Accelerating reconnaissance phases of security assessments</li> </ul> <p>Analyzed Headers:</p> <ul> <li>Server: Web server type and version (Apache, Nginx, IIS)</li> <li>X-Powered-By: Application framework (PHP, Express, Django)</li> <li>X-AspNet-Version: ASP.NET framework version</li> <li>X-AspNetMvc-Version: ASP.NET MVC version</li> <li>X-Framework: Custom framework identifiers</li> <li>X-Generator: Content management systems (WordPress, Drupal)</li> <li>X-Drupal-Cache: Drupal CMS indicator</li> <li>X-Mod-Pagespeed: Google PageSpeed module</li> <li>X-Varnish: Varnish Cache presence</li> <li>X-Served-By: CDN or hosting service information</li> <li>X-Cache: Caching layer details</li> <li>X-Runtime: Application runtime information</li> </ul> <p>CVE Integration:</p> <p>This test integrates with the NIST NVD (National Vulnerability Database) to:</p> <ul> <li>Query known vulnerabilities for detected technologies</li> <li>Assess severity based on CVSS scores</li> <li>Elevate threat levels when high-severity CVEs exist</li> <li>Provide contextual vulnerability intelligence</li> </ul> <p>Threat Assessment Algorithm:</p> <pre><code>Base Level (by exposure count):\n  0 exposures  \u2192 None\n  1-2 exposures \u2192 Info\n  3-4 exposures \u2192 Low\n  5+ exposures  \u2192 Medium\n\nCVE Enhancement:\n  High severity CVE present    \u2192 Critical\n  6+ medium severity CVEs       \u2192 High\n  1-5 medium severity CVEs      \u2192 Medium\n  11+ low severity CVEs         \u2192 Medium\n  1-10 low severity CVEs        \u2192 Low\n\nHeuristic Enhancement:\n  Debug/test/dev identifiers    \u2192 Critical\n  Common web servers exposed    \u2192 High\n</code></pre> <p>Best Practices:</p> <p>To mitigate information disclosure:</p> <ul> <li>Remove or customize Server headers</li> <li>Disable X-Powered-By and version headers</li> <li>Use reverse proxies to normalize header output</li> <li>Implement header security policies</li> <li>Regular security audits of exposed headers</li> </ul> <p>Package Tests provides the core testing framework for security analysis of HTTP responses. This file defines fundamental types including ThreatLevel enumeration, TestResult structure, and the ResponseTest interface that all security tests must implement.</p> <p>The framework enables:</p> <ul> <li>Standardized security threat classification (None to Critical)</li> <li>Structured test results with metadata</li> <li>Extensible test implementations</li> <li>JSON serialization for reporting</li> </ul> <p>Package Tests provides security test implementations for HTTP response analysis. This file contains the X-Content-Type-Options test that checks for proper MIME type sniffing protection to prevent content-type confusion attacks.</p> <p>Package Tests provides security test implementations for HTTP response analysis. This file contains the X-Frame-Options test that checks for proper clickjacking protection by analyzing X-Frame-Options and Content-Security-Policy frame directives.</p>"},{"location":"App/Tests/#index","title":"Index","text":"<ul> <li>Variables</li> <li>func aggregateSecurityIssues(analysis *CookieSecurityAnalysis)</li> <li>func analyzeCrossOriginHeaders(coepHeader, corpHeader, coopHeader string) map[string]interface{}</li> <li>func analyzeDirectiveSecurity(analysis *CSPAnalysis)</li> <li>func analyzeHSTSHeader(hstsHeader string) map[string]interface{}</li> <li>func analyzeIndividualCookieSecurity(detail *CookieSecurityDetail, cookie *http.Cookie, headers []string, index int)</li> <li>func analyzePermissionsPolicyHeader(permissionsPolicyHeader string) map[string]interface{}</li> <li>func analyzeReferrerPolicyHeader(referrerPolicyHeader string) map[string]interface{}</li> <li>func analyzeXContentTypeOptionsHeader(xContentTypeHeader string) map[string]interface{}</li> <li>func assessEmbeddingCapability(xframeDirective, cspFrameValue string, xframeValid bool) string</li> <li>func calculateCookieSecurityScore(analysis *CookieSecurityAnalysis)</li> <li>func calculateIndividualCookieScore(detail CookieSecurityDetail) int</li> <li>func calculateObfuscationScore(analysis *JSObfuscationAnalysis)</li> <li>func calculatePolicyStrength(analysis *CSPAnalysis)</li> <li>func checkMissingDirectives(analysis *CSPAnalysis)</li> <li>func containsHash(values []string) bool</li> <li>func containsNonce(values []string) bool</li> <li>func detectBase64Encoding(analysis *JSObfuscationAnalysis, content string)</li> <li>func detectCharCodeObfuscation(analysis *JSObfuscationAnalysis, content string)</li> <li>func detectDynamicExecution(analysis *JSObfuscationAnalysis, content string)</li> <li>func detectEncodedStrings(analysis *JSObfuscationAnalysis, content string)</li> <li>func detectEscapeSequences(analysis *JSObfuscationAnalysis, content string)</li> <li>func detectMaliciousIndicators(analysis *JSObfuscationAnalysis, content string)</li> <li>func detectSuspiciousPatterns(analysis *JSObfuscationAnalysis, content string)</li> <li>func detectTechnologies(headerName string, headerValue string) map[string]string</li> <li>func determineCSPProtectionLevel(analysis *CSPAnalysis)</li> <li>func determineObfuscationLevel(analysis *JSObfuscationAnalysis)</li> <li>func determineProtectionLevel(xframeDirective, cspFrameValue string, xframeValid bool) string</li> <li>func evaluateDirectiveCompliance(analysis *CSPAnalysis, directiveName string, values []string)</li> <li>func extractFrameAncestorsValue(cspHeader string) string</li> <li>func extractMaxAge(hstsHeader string) int</li> <li>func extractScriptContent(html string) []string</li> <li>func extractVersion(headerValue, technology string) string</li> <li>func formatDuration(d time.Duration) string</li> <li>func formatMaxAge(seconds int) string</li> <li>func generateCSPDescription(analysis CSPAnalysis) string</li> <li>func generateCookieDescription(analysis CookieSecurityAnalysis) string</li> <li>func generateCrossOriginDescription(metadata map[string]interface{}) string</li> <li>func generateDescription(protectionLevel string, hasXFrame, hasCSP bool, canBeEmbedded string) string</li> <li>func generateHSTSDescription(metadata map[string]interface{}) string</li> <li>func generateObfuscationDescription(analysis JSObfuscationAnalysis) string</li> <li>func generatePermissionsPolicyDescription(metadata map[string]interface{}) string</li> <li>func generateReferrerPolicyDescription(metadata map[string]interface{}) string</li> <li>func generateServerExposureDescription(analysis *ServerHeaderAnalysis) string</li> <li>func generateXContentTypeOptionsDescription(metadata map[string]interface{}) string</li> <li>func getSameSiteString(sameSite http.SameSite) string</li> <li>func hasOnlyBroadSources(cspLower string) bool</li> <li>func hasSpecificDomains(cspLower string) bool</li> <li>func isAllowlistRestricted(allowlist string) bool</li> <li>func isPredictableValue(value string) bool</li> <li>func isSessionCookie(cookie *http.Cookie) bool</li> <li>type CSPAnalysis</li> <li>func analyzeCSPHeader(cspHeader string) CSPAnalysis</li> <li>type CookieSecurityAnalysis</li> <li>func analyzeCookieSecurity(cookies []*http.Cookie, headers http.Header) CookieSecurityAnalysis</li> <li>type CookieSecurityDetail</li> <li>func analyzeSingleCookie(cookie *http.Cookie, setCookieHeaders []string, index int) CookieSecurityDetail</li> <li>type CrossOriginAnalysis</li> <li>type JSObfuscationAnalysis</li> <li>func analyzeJSObfuscation(content string) JSObfuscationAnalysis</li> <li>type ResponseTest</li> <li>func NewCSPTest() *ResponseTest</li> <li>func NewCookieSecurityTest() *ResponseTest</li> <li>func NewCrossOriginTest() *ResponseTest</li> <li>func NewHSTSTest() *ResponseTest</li> <li>func NewHTTPSTest() *ResponseTest</li> <li>func NewJSObfuscationTest() *ResponseTest</li> <li>func NewPermissionsPolicyTest() *ResponseTest</li> <li>func NewReferrerPolicyTest() *ResponseTest</li> <li>func NewServerHeaderTest() *ResponseTest</li> <li>func NewXContentTypeOptionsTest() *ResponseTest</li> <li>func NewXFrameTest() *ResponseTest</li> <li>func (brt *ResponseTest) GetDescription() string</li> <li>func (brt *ResponseTest) GetId() string</li> <li>func (brt *ResponseTest) GetName() string</li> <li>func (rt *ResponseTest) Run(params ResponseTestParams) TestResult</li> <li>type ResponseTestParams</li> <li>type ServerHeaderAnalysis</li> <li>func analyzeServerHeaders(headers map[string]string) *ServerHeaderAnalysis</li> <li>type TestResult</li> <li>type TestResultWrapper</li> <li>type ThreatLevel</li> <li>func evaluateCSPThreatLevel(analysis CSPAnalysis) ThreatLevel</li> <li>func evaluateCookieThreatLevel(analysis CookieSecurityAnalysis) ThreatLevel</li> <li>func evaluateCrossOriginThreatLevel(metadata map[string]interface{}) ThreatLevel</li> <li>func evaluateHSTSThreatLevel(metadata map[string]interface{}) ThreatLevel</li> <li>func evaluateObfuscationThreat(analysis JSObfuscationAnalysis) ThreatLevel</li> <li>func evaluatePermissionsPolicyThreatLevel(metadata map[string]interface{}) ThreatLevel</li> <li>func evaluateReferrerPolicyThreatLevel(metadata map[string]interface{}) ThreatLevel</li> <li>func evaluateServerExposureThreatLevel(analysis *ServerHeaderAnalysis) ThreatLevel</li> <li>func evaluateXContentTypeOptionsThreatLevel(metadata map[string]interface{}) ThreatLevel</li> <li>func mapCVEThreatLevel(assessment CVE.VulnerabilityAssessment) ThreatLevel</li> <li>func (t ThreatLevel) MarshalJSON() ([]byte, error)</li> <li>func (t ThreatLevel) String() string</li> </ul>"},{"location":"App/Tests/#variables","title":"Variables","text":"<p>cspBroadSources contains CSP sources that allow broad access and don't represent specific domain restrictions.</p> <pre><code>var cspBroadSources = map[string]bool{\n    \"https:\": true,\n    \"http:\":  true,\n    \"*\":      true,\n}\n</code></pre> <p>cspKeywords contains CSP keywords that are not domain restrictions.</p> <pre><code>var cspKeywords = map[string]bool{\n    \"'self'\": true,\n    \"'none'\": true,\n}\n</code></pre> <p></p>"},{"location":"App/Tests/#func-aggregatesecurityissues","title":"func aggregateSecurityIssues","text":"<pre><code>func aggregateSecurityIssues(analysis *CookieSecurityAnalysis)\n</code></pre> <p>aggregateSecurityIssues creates high-level security issue summaries</p> <p></p>"},{"location":"App/Tests/#func-analyzecrossoriginheaders","title":"func analyzeCrossOriginHeaders","text":"<pre><code>func analyzeCrossOriginHeaders(coepHeader, corpHeader, coopHeader string) map[string]interface{}\n</code></pre> <p>analyzeCrossOriginHeaders parses and analyzes all three cross-origin security headers to determine the overall security posture and isolation effectiveness.</p> <p>Parameters:</p> <ul> <li>coepHeader: Cross-Origin-Embedder-Policy header value</li> <li>corpHeader: Cross-Origin-Resource-Policy header value</li> <li>coopHeader: Cross-Origin-Opener-Policy header value</li> </ul> <p>Returns:</p> <ul> <li>map[string]interface{}: Structured metadata containing cross-origin security analysis</li> </ul> <p></p>"},{"location":"App/Tests/#func-analyzedirectivesecurity","title":"func analyzeDirectiveSecurity","text":"<pre><code>func analyzeDirectiveSecurity(analysis *CSPAnalysis)\n</code></pre> <p>analyzeDirectiveSecurity checks each directive for security issues</p> <p></p>"},{"location":"App/Tests/#func-analyzehstsheader","title":"func analyzeHSTSHeader","text":"<pre><code>func analyzeHSTSHeader(hstsHeader string) map[string]interface{}\n</code></pre> <p>analyzeHSTSHeader parses the Strict-Transport-Security header value and extracts configuration directives into a structured metadata map. This function performs case-insensitive parsing to handle various header formats.</p> <p>Parsed directives:</p> <ul> <li>max-age: The time (in seconds) that the browser should remember to access the site using HTTPS</li> <li>includeSubDomains: Whether the HSTS policy applies to all subdomains</li> <li>preload: Whether the site is eligible for HSTS preload list inclusion</li> </ul> <p>The function handles various header formats including:</p> <ul> <li>\"max-age=31536000; includeSubDomains; preload\"</li> <li>\"max-age=31536000\"</li> <li>\"MAX-AGE=31536000; INCLUDESUBDOMAINS\" (case-insensitive)</li> </ul> <p>Parameters:</p> <ul> <li>hstsHeader: Raw Strict-Transport-Security header value from HTTP response</li> </ul> <p>Returns:</p> <ul> <li>map[string]interface{}: Structured metadata containing:</li> <li>\"include_subdomains\" (bool): includeSubDomains directive present</li> <li>\"preload\" (bool): preload directive present</li> <li>\"max_age\" (int): max-age value in seconds (0 if missing/invalid)</li> <li>\"directives\" ([]string): List of present optional directives</li> </ul> <p>Example:</p> <pre><code>header := \"max-age=31536000; includeSubDomains; preload\"\nmetadata := analyzeHSTSHeader(header)\n// Returns: {\n//   \"include_subdomains\": true,\n//   \"preload\": true,\n//   \"max_age\": 31536000,\n//   \"directives\": [\"includeSubDomains\", \"preload\"]\n// }\n</code></pre> <p></p>"},{"location":"App/Tests/#func-analyzeindividualcookiesecurity","title":"func analyzeIndividualCookieSecurity","text":"<pre><code>func analyzeIndividualCookieSecurity(detail *CookieSecurityDetail, cookie *http.Cookie, headers []string, index int)\n</code></pre> <p>analyzeIndividualCookieSecurity identifies specific security issues</p> <p></p>"},{"location":"App/Tests/#func-analyzepermissionspolicyheader","title":"func analyzePermissionsPolicyHeader","text":"<pre><code>func analyzePermissionsPolicyHeader(permissionsPolicyHeader string) map[string]interface{}\n</code></pre>"},{"location":"App/Tests/#func-analyzereferrerpolicyheader","title":"func analyzeReferrerPolicyHeader","text":"<pre><code>func analyzeReferrerPolicyHeader(referrerPolicyHeader string) map[string]interface{}\n</code></pre> <p>analyzeReferrerPolicyHeader parses the Referrer-Policy header value and extracts policy directives into a structured metadata map. This function handles multiple comma-separated values and normalizes case variations.</p> <p>Parsed information:</p> <ul> <li>policies: List of referrer policy directives from the header</li> <li>effective_policy: The policy that will be applied (last valid one)</li> <li>policy_count: Number of policies specified</li> <li>has_unsafe: Whether unsafe policies are present</li> </ul> <p>The function handles various header formats including:</p> <ul> <li>\"strict-origin-when-cross-origin\"</li> <li>\"no-referrer, strict-origin-when-cross-origin\" (multiple policies)</li> <li>\"SAME-ORIGIN\" (case-insensitive)</li> <li>\"no-referrer , origin\" (with spaces)</li> </ul> <p>Parameters:</p> <ul> <li>referrerPolicyHeader: Raw Referrer-Policy header value from HTTP response</li> </ul> <p>Returns:</p> <ul> <li>map[string]interface{}: Structured metadata containing:</li> <li>policies: []string - List of policy directives</li> <li>effective_policy: string - The effective policy (last valid one)</li> <li>policy_count: int - Number of policies specified</li> <li>has_unsafe: bool - Whether unsafe policies (unsafe-url) are present</li> <li>invalid_policies: []string - List of unrecognized policy values</li> </ul> <p>Example:</p> <pre><code>metadata1 := analyzeReferrerPolicyHeader(\"strict-origin-when-cross-origin\")\n// Returns: {policies: [\"strict-origin-when-cross-origin\"], effective_policy: \"strict-origin-when-cross-origin\", ...}\n\nmetadata2 := analyzeReferrerPolicyHeader(\"no-referrer, unsafe-url\")\n// Returns: {policies: [\"no-referrer\", \"unsafe-url\"], effective_policy: \"unsafe-url\", has_unsafe: true, ...}\n</code></pre> <p></p>"},{"location":"App/Tests/#func-analyzexcontenttypeoptionsheader","title":"func analyzeXContentTypeOptionsHeader","text":"<pre><code>func analyzeXContentTypeOptionsHeader(xContentTypeHeader string) map[string]interface{}\n</code></pre> <p>analyzeXContentTypeOptionsHeader parses the X-Content-Type-Options header value</p> <p></p>"},{"location":"App/Tests/#func-assessembeddingcapability","title":"func assessEmbeddingCapability","text":"<pre><code>func assessEmbeddingCapability(xframeDirective, cspFrameValue string, xframeValid bool) string\n</code></pre> <p>assessEmbeddingCapability determines whether the page can be embedded in an iframe based on the configured frame protection headers.</p> <p>Parameters:</p> <ul> <li>xframeDirective: X-Frame-Options directive value</li> <li>cspFrameValue: CSP frame-ancestors directive value</li> <li>xframeValid: Whether X-Frame-Options syntax is valid</li> </ul> <p>Returns:</p> <ul> <li>string: Embedding capability (blocked, same-origin, limited, allowed)</li> </ul> <p></p>"},{"location":"App/Tests/#func-calculatecookiesecurityscore","title":"func calculateCookieSecurityScore","text":"<pre><code>func calculateCookieSecurityScore(analysis *CookieSecurityAnalysis)\n</code></pre> <p>calculateCookieSecurityScore calculates overall security score (0-100)</p> <p></p>"},{"location":"App/Tests/#func-calculateindividualcookiescore","title":"func calculateIndividualCookieScore","text":"<pre><code>func calculateIndividualCookieScore(detail CookieSecurityDetail) int\n</code></pre> <p>calculateIndividualCookieScore calculates security score for a single cookie</p> <p></p>"},{"location":"App/Tests/#func-calculateobfuscationscore","title":"func calculateObfuscationScore","text":"<pre><code>func calculateObfuscationScore(analysis *JSObfuscationAnalysis)\n</code></pre> <p>calculateObfuscationScore calculates overall obfuscation score (0-100)</p> <p></p>"},{"location":"App/Tests/#func-calculatepolicystrength","title":"func calculatePolicyStrength","text":"<pre><code>func calculatePolicyStrength(analysis *CSPAnalysis)\n</code></pre> <p>calculatePolicyStrength calculates a numerical strength score (0-100)</p> <p></p>"},{"location":"App/Tests/#func-checkmissingdirectives","title":"func checkMissingDirectives","text":"<pre><code>func checkMissingDirectives(analysis *CSPAnalysis)\n</code></pre> <p>checkMissingDirectives identifies important missing CSP directives</p> <p></p>"},{"location":"App/Tests/#func-containshash","title":"func containsHash","text":"<pre><code>func containsHash(values []string) bool\n</code></pre>"},{"location":"App/Tests/#func-containsnonce","title":"func containsNonce","text":"<pre><code>func containsNonce(values []string) bool\n</code></pre> <p>CSP-specific utility functions</p> <p></p>"},{"location":"App/Tests/#func-detectbase64encoding","title":"func detectBase64Encoding","text":"<pre><code>func detectBase64Encoding(analysis *JSObfuscationAnalysis, content string)\n</code></pre> <p>detectBase64Encoding detects Base64 encoded strings</p> <p></p>"},{"location":"App/Tests/#func-detectcharcodeobfuscation","title":"func detectCharCodeObfuscation","text":"<pre><code>func detectCharCodeObfuscation(analysis *JSObfuscationAnalysis, content string)\n</code></pre> <p>detectCharCodeObfuscation detects String.fromCharCode obfuscation</p> <p></p>"},{"location":"App/Tests/#func-detectdynamicexecution","title":"func detectDynamicExecution","text":"<pre><code>func detectDynamicExecution(analysis *JSObfuscationAnalysis, content string)\n</code></pre> <p>detectDynamicExecution detects eval, Function, and similar dynamic code execution</p> <p></p>"},{"location":"App/Tests/#func-detectencodedstrings","title":"func detectEncodedStrings","text":"<pre><code>func detectEncodedStrings(analysis *JSObfuscationAnalysis, content string)\n</code></pre> <p>detectEncodedStrings detects various string encoding methods</p> <p></p>"},{"location":"App/Tests/#func-detectescapesequences","title":"func detectEscapeSequences","text":"<pre><code>func detectEscapeSequences(analysis *JSObfuscationAnalysis, content string)\n</code></pre> <p>detectEscapeSequences detects hex and unicode escape sequences</p> <p></p>"},{"location":"App/Tests/#func-detectmaliciousindicators","title":"func detectMaliciousIndicators","text":"<pre><code>func detectMaliciousIndicators(analysis *JSObfuscationAnalysis, content string)\n</code></pre> <p>detectMaliciousIndicators detects patterns strongly associated with malicious code</p> <p></p>"},{"location":"App/Tests/#func-detectsuspiciouspatterns","title":"func detectSuspiciousPatterns","text":"<pre><code>func detectSuspiciousPatterns(analysis *JSObfuscationAnalysis, content string)\n</code></pre> <p>detectSuspiciousPatterns detects patterns commonly associated with obfuscation</p> <p></p>"},{"location":"App/Tests/#func-detecttechnologies","title":"func detectTechnologies","text":"<pre><code>func detectTechnologies(headerName string, headerValue string) map[string]string\n</code></pre> <p>detectTechnologies identifies specific technologies and their versions from HTTP header values.</p> <p>This function uses pattern matching and heuristics to recognize common web servers, application frameworks, content management systems, and infrastructure components based on the header name and value.</p> <p>Detection Strategy:</p> <p>The function employs a switch-case approach for each header type:</p> <ul> <li>Server: Detects web servers (Apache, Nginx, IIS, Cloudflare, etc.)</li> <li>X-Powered-By: Identifies frameworks (Express, Django, PHP, Laravel, etc.)</li> <li>X-AspNet-Version: Captures ASP.NET version directly</li> <li>X-AspNetMvc-Version: Captures ASP.NET MVC version directly</li> <li>X-Generator: Detects CMS (Drupal, WordPress)</li> <li>Other headers: Various specialized detections</li> </ul> <p>Version Extraction:</p> <p>When possible, versions are extracted using the extractVersion() function which parses patterns like \"nginx/1.18.0\" or \"PHP/7.4.3\".</p> <p>Recognized Technologies:</p> <p>Web Servers:</p> <ul> <li>Apache, Nginx, Microsoft IIS, Cloudflare, Gunicorn, Uvicorn</li> </ul> <p>Frameworks:</p> <ul> <li>Express.js, Django, ASP.NET, PHP, Laravel, Ruby on Rails, Flask, Spring Framework</li> </ul> <p>CMS:</p> <ul> <li>Drupal, WordPress</li> </ul> <p>Infrastructure:</p> <ul> <li>Google PageSpeed, Varnish Cache, Dynamic Runtime</li> </ul> <p>Parameters:</p> <ul> <li>headerName: The HTTP header name (e.g., \"Server\", \"X-Powered-By\")</li> <li>headerValue: The actual value of the header</li> </ul> <p>Returns:</p> <ul> <li>map[string]string: Map of detected technologies to their versions</li> <li>Keys are technology names (e.g., \"Nginx\", \"PHP\")</li> <li>Values are versions if detected, or empty string/generic indicator</li> </ul> <p>Example:</p> <pre><code>// Web server detection\ntech := detectTechnologies(\"Server\", \"nginx/1.18.0 (Ubuntu)\")\n// Returns: {\"Nginx\": \"1.18.0\"}\n\n// Framework detection\ntech := detectTechnologies(\"X-Powered-By\", \"PHP/7.4.3\")\n// Returns: {\"PHP\": \"7.4.3\"}\n\n// Multiple technologies in one header\ntech := detectTechnologies(\"Server\", \"Apache/2.4.41 (Ubuntu) OpenSSL/1.1.1f\")\n// Returns: {\"Apache\": \"2.4.41\"}\n\n// Version-less detection\ntech := detectTechnologies(\"X-Powered-By\", \"Express\")\n// Returns: {\"Express.js\": \"\"}\n</code></pre> <p>Note:</p> <p>Case-insensitive matching is used to handle variations in header formatting. Not all technologies can have versions extracted; some return empty strings.</p> <p></p>"},{"location":"App/Tests/#func-determinecspprotectionlevel","title":"func determineCSPProtectionLevel","text":"<pre><code>func determineCSPProtectionLevel(analysis *CSPAnalysis)\n</code></pre> <p>determineCSPProtectionLevel sets overall protection assessment</p> <p></p>"},{"location":"App/Tests/#func-determineobfuscationlevel","title":"func determineObfuscationLevel","text":"<pre><code>func determineObfuscationLevel(analysis *JSObfuscationAnalysis)\n</code></pre> <p>determineObfuscationLevel categorizes obfuscation severity</p> <p></p>"},{"location":"App/Tests/#func-determineprotectionlevel","title":"func determineProtectionLevel","text":"<pre><code>func determineProtectionLevel(xframeDirective, cspFrameValue string, xframeValid bool) string\n</code></pre> <p>determineProtectionLevel assesses the overall frame protection strength based on configured headers and directives.</p> <p>Parameters:</p> <ul> <li>xframeDirective: X-Frame-Options directive value</li> <li>cspFrameValue: CSP frame-ancestors directive value</li> <li>xframeValid: Whether X-Frame-Options syntax is valid</li> </ul> <p>Returns:</p> <ul> <li>string: Protection level (excellent, good, limited, weak, vulnerable)</li> </ul> <p></p>"},{"location":"App/Tests/#func-evaluatedirectivecompliance","title":"func evaluateDirectiveCompliance","text":"<pre><code>func evaluateDirectiveCompliance(analysis *CSPAnalysis, directiveName string, values []string)\n</code></pre> <p>evaluateDirectiveCompliance assesses individual directive configurations</p> <p></p>"},{"location":"App/Tests/#func-extractframeancestorsvalue","title":"func extractFrameAncestorsValue","text":"<pre><code>func extractFrameAncestorsValue(cspHeader string) string\n</code></pre> <p>extractFrameAncestorsValue parses the Content-Security-Policy header to extract the frame-ancestors directive value.</p> <p>Parameters:</p> <ul> <li>cspHeader: Complete CSP header value</li> </ul> <p>Returns:</p> <ul> <li>string: frame-ancestors directive value or empty string if not found</li> </ul> <p></p>"},{"location":"App/Tests/#func-extractmaxage","title":"func extractMaxAge","text":"<pre><code>func extractMaxAge(hstsHeader string) int\n</code></pre> <p>extractMaxAge extracts and parses the max-age directive value from the HSTS header. The max-age directive specifies the duration (in seconds) that the browser should remember to access the site exclusively over HTTPS.</p> <p>The function performs case-insensitive parsing and handles various formats:</p> <ul> <li>\"max-age=31536000\"</li> <li>\"MAX-AGE=31536000\"</li> <li>\"max-age=31536000; includeSubDomains\"</li> </ul> <p>Parsing process:</p> <ol> <li>Split header by semicolon to separate directives</li> <li>Trim whitespace from each directive</li> <li>Look for \"max-age=\" prefix (case-insensitive)</li> <li>Extract numeric value after the equals sign</li> <li>Convert to integer</li> </ol> <p>Parameters:</p> <ul> <li>hstsHeader: Raw Strict-Transport-Security header value</li> </ul> <p>Returns:</p> <ul> <li>int: max-age value in seconds, or 0 if not found or invalid</li> </ul> <p>Example:</p> <pre><code>age1 := extractMaxAge(\"max-age=31536000; includeSubDomains\")  // Returns: 31536000\nage2 := extractMaxAge(\"includeSubDomains; preload\")           // Returns: 0\nage3 := extractMaxAge(\"max-age=invalid\")                      // Returns: 0\n</code></pre> <p></p>"},{"location":"App/Tests/#func-extractscriptcontent","title":"func extractScriptContent","text":"<pre><code>func extractScriptContent(html string) []string\n</code></pre> <p>extractScriptContent extracts JavaScript from script tags</p> <p></p>"},{"location":"App/Tests/#func-extractversion","title":"func extractVersion","text":"<pre><code>func extractVersion(headerValue, technology string) string\n</code></pre> <p>extractVersion attempts to extract version information from HTTP header values using pattern recognition for common version formatting conventions.</p> <p>This function parses header values to isolate version numbers following technology names, handling various separator styles and formats commonly used in HTTP headers.</p> <p>Supported Version Patterns:</p> <ul> <li>Slash separator: \"nginx/1.18.0\"</li> <li>Hyphen separator: \"PHP-7.4.3\"</li> <li>Direct placement: \"Apache 2.4.41\"</li> <li>Version prefix: \"v1.18.0\" or \"V1.18.0\"</li> </ul> <p>Algorithm:</p> <ol> <li>Convert to lowercase for case-insensitive matching</li> <li>Locate the technology name within the header value</li> <li>Examine characters after the technology name</li> <li>Identify version start (first digit or after separator)</li> <li>Extract consecutive version characters (digits, dots, hyphens)</li> <li>Return the isolated version string</li> </ol> <p>Version Character Rules:</p> <ul> <li>Digits (0-9): Valid version characters</li> <li>Dots (.): Valid separators (1.18.0)</li> <li>Hyphens (-): Valid for pre-release versions (1.0.0-beta)</li> <li>Any other character: Terminates version extraction</li> </ul> <p>Parameters:</p> <ul> <li>headerValue: The complete HTTP header value (e.g., \"nginx/1.18.0 (Ubuntu)\")</li> <li>technology: The technology name to locate (e.g., \"nginx\")</li> </ul> <p>Returns:</p> <ul> <li>string: Extracted version number, or empty string if not found</li> </ul> <p>Example:</p> <pre><code>// Standard slash format\nversion := extractVersion(\"nginx/1.18.0 (Ubuntu)\", \"nginx\")\n// Returns: \"1.18.0\"\n\n// Hyphen separator\nversion := extractVersion(\"PHP-7.4.3\", \"PHP\")\n// Returns: \"7.4.3\"\n\n// Version prefix\nversion := extractVersion(\"Apache v2.4.41\", \"Apache\")\n// Returns: \"2.4.41\"\n\n// Direct placement\nversion := extractVersion(\"IIS 10.0\", \"IIS\")\n// Returns: \"10.0\"\n\n// No version found\nversion := extractVersion(\"Cloudflare\", \"Cloudflare\")\n// Returns: \"\"\n\n// Complex header\nversion := extractVersion(\"Apache/2.4.41 (Ubuntu) OpenSSL/1.1.1f\", \"Apache\")\n// Returns: \"2.4.41\"\n</code></pre> <p>Note:</p> <p>This function uses case-insensitive matching for robustness. It only extracts the first version number encountered after the technology name.</p> <p></p>"},{"location":"App/Tests/#func-formatduration","title":"func formatDuration","text":"<pre><code>func formatDuration(d time.Duration) string\n</code></pre> <p>formatDuration formats a duration in human-readable format</p> <p></p>"},{"location":"App/Tests/#func-formatmaxage","title":"func formatMaxAge","text":"<pre><code>func formatMaxAge(seconds int) string\n</code></pre> <p>formatMaxAge converts a max-age value in seconds to a human-readable duration string. The function automatically selects the most appropriate time unit (years, months, days, hours, or seconds) based on the magnitude of the value.</p> <p>Conversion logic:</p> <ul> <li>\u2265 1 year (31,536,000 sec): Express in years</li> <li>\u2265 1 month (2,592,000 sec): Express in months</li> <li>\u2265 1 day (86,400 sec): Express in days</li> <li>\u2265 1 hour (3,600 sec): Express in hours</li> <li>\\&lt; 1 hour: Express in seconds</li> </ul> <p>Singular/plural handling:</p> <ul> <li>Uses singular form for value of 1 (e.g., \"1 year\", \"1 day\")</li> <li>Uses plural form for all other values (e.g., \"2 years\", \"30 days\")</li> </ul> <p>Parameters:</p> <ul> <li>seconds: max-age value in seconds</li> </ul> <p>Returns:</p> <ul> <li>string: Human-readable duration with appropriate unit</li> </ul> <p>Examples:</p> <pre><code>formatMaxAge(31536000)     // Returns: \"1 year max-age\"\nformatMaxAge(63072000)     // Returns: \"2 years max-age\"\nformatMaxAge(2592000)      // Returns: \"1 month max-age\"\nformatMaxAge(7776000)      // Returns: \"3 months max-age\"\nformatMaxAge(86400)        // Returns: \"1 day max-age\"\nformatMaxAge(259200)       // Returns: \"3 days max-age\"\nformatMaxAge(3600)         // Returns: \"1 hour max-age\"\nformatMaxAge(7200)         // Returns: \"2 hours max-age\"\nformatMaxAge(300)          // Returns: \"300 seconds max-age\"\n</code></pre> <p></p>"},{"location":"App/Tests/#func-generatecspdescription","title":"func generateCSPDescription","text":"<pre><code>func generateCSPDescription(analysis CSPAnalysis) string\n</code></pre> <p>generateCSPDescription creates a detailed description of CSP findings</p> <p></p>"},{"location":"App/Tests/#func-generatecookiedescription","title":"func generateCookieDescription","text":"<pre><code>func generateCookieDescription(analysis CookieSecurityAnalysis) string\n</code></pre> <p>generateCookieDescription creates detailed description of findings</p> <p></p>"},{"location":"App/Tests/#func-generatecrossorigindescription","title":"func generateCrossOriginDescription","text":"<pre><code>func generateCrossOriginDescription(metadata map[string]interface{}) string\n</code></pre> <p>generateCrossOriginDescription creates a detailed description of the cross-origin security headers analysis results, including findings and recommendations.</p> <p>Parameters:</p> <ul> <li>metadata: Analyzed cross-origin headers metadata</li> </ul> <p>Returns:</p> <ul> <li>string: Comprehensive description of cross-origin security status</li> </ul> <p></p>"},{"location":"App/Tests/#func-generatedescription","title":"func generateDescription","text":"<pre><code>func generateDescription(protectionLevel string, hasXFrame, hasCSP bool, canBeEmbedded string) string\n</code></pre> <p>generateDescription creates a description based on protection analysis</p> <p></p>"},{"location":"App/Tests/#func-generatehstsdescription","title":"func generateHSTSDescription","text":"<pre><code>func generateHSTSDescription(metadata map[string]interface{}) string\n</code></pre> <p>generateHSTSDescription creates a human-readable description of the HSTS configuration analysis including the configuration details and security assessment. The description provides actionable information about the HSTS implementation quality.</p> <p>Description components:</p> <ul> <li>Human-readable max-age duration (e.g., \"1 year\", \"6 months\", \"30 days\")</li> <li>List of present directives (includeSubDomains, preload)</li> <li>Security assessment (Excellent, Good, Acceptable, or Weak)</li> <li>Recommendations for improvement when applicable</li> </ul> <p>Special cases handled:</p> <ul> <li>max-age = 0 or missing: \"HSTS header present but missing or invalid max-age directive\"</li> <li>Weak configuration: Includes suggestion to increase max-age</li> </ul> <p>Parameters:</p> <ul> <li>metadata: Parsed HSTS header metadata containing max_age, directives, and flags</li> </ul> <p>Returns:</p> <ul> <li>string: Formatted description for the TestResult</li> </ul> <p>Example outputs:</p> <pre><code>// Excellent configuration\n\"HSTS header configured with 1 year max-age and includes: includeSubDomains, preload - Excellent security configuration\"\n\n// Good configuration\n\"HSTS header configured with 2 years max-age and includes: includeSubDomains - Good security configuration\"\n\n// Weak configuration\n\"HSTS header configured with 30 days max-age - Weak security configuration, consider increasing max-age\"\n\n// Missing max-age\n\"HSTS header present but missing or invalid max-age directive\"\n</code></pre> <p></p>"},{"location":"App/Tests/#func-generateobfuscationdescription","title":"func generateObfuscationDescription","text":"<pre><code>func generateObfuscationDescription(analysis JSObfuscationAnalysis) string\n</code></pre> <p>generateObfuscationDescription creates detailed description</p> <p></p>"},{"location":"App/Tests/#func-generatepermissionspolicydescription","title":"func generatePermissionsPolicyDescription","text":"<pre><code>func generatePermissionsPolicyDescription(metadata map[string]interface{}) string\n</code></pre> <p>generatePermissionsPolicyDescription creates a human-readable description of the Permissions-Policy analysis results.</p> <p></p>"},{"location":"App/Tests/#func-generatereferrerpolicydescription","title":"func generateReferrerPolicyDescription","text":"<pre><code>func generateReferrerPolicyDescription(metadata map[string]interface{}) string\n</code></pre> <p>generateReferrerPolicyDescription creates a human-readable description of the Referrer-Policy analysis results, including findings, risks, and recommendations.</p> <p>The description covers:</p> <ul> <li>Current policy configuration assessment</li> <li>Privacy and security implications</li> <li>Information leakage risks</li> <li>Specific recommendations for improvement</li> <li>Policy conflicts or configuration warnings</li> </ul> <p>Parameters:</p> <ul> <li>metadata: Parsed referrer policy metadata from analyzeReferrerPolicyHeader</li> </ul> <p>Returns:</p> <ul> <li>string: Detailed human-readable description of findings and recommendations</li> </ul> <p>Example output:</p> <pre><code>\"Referrer-Policy configured with 'strict-origin-when-cross-origin' - excellent privacy\n protection that balances security with functionality. This W3C recommended policy sends\n full URL for same-origin requests and only origin for cross-origin requests...\"\n</code></pre> <p></p>"},{"location":"App/Tests/#func-generateserverexposuredescription","title":"func generateServerExposureDescription","text":"<pre><code>func generateServerExposureDescription(analysis *ServerHeaderAnalysis) string\n</code></pre> <p>generateServerExposureDescription creates a human-readable description of server header information disclosure findings.</p> <p>This function synthesizes the analysis results into clear, concise descriptions suitable for security reports, console output, and API responses. It provides context about the exposure scope and identified technologies.</p> <p>Description Format:</p> <p>No Exposure:</p> <ul> <li>\"No server technology information disclosed in headers - good security practice\"</li> </ul> <p>With Exposure:</p> <ul> <li>Pattern: \"{count} header(s) expose server information. Detected technologies: {tech_list}\"</li> <li>Single: \"1 header exposes server information. Detected technologies: Nginx\"</li> <li>Multiple: \"5 headers expose server information. Detected technologies: Apache, PHP, OpenSSL\"</li> </ul> <p>Description Components:</p> <ol> <li>Exposure Count: Quantifies how many headers reveal information</li> <li>Technology List: Comma-separated list of detected technologies</li> <li>Grammar: Proper singular/plural handling (\"header\" vs \"headers\")</li> </ol> <p>Parameters:</p> <ul> <li>analysis: ServerHeaderAnalysis containing exposure and technology data</li> </ul> <p>Returns:</p> <ul> <li>string: Human-readable description of findings</li> </ul> <p>Example:</p> <pre><code>// No exposure scenario\nanalysis := &amp;ServerHeaderAnalysis{\n    total_exposures: 0,\n    technologies: []string{},\n}\ndesc := generateServerExposureDescription(analysis)\n// Returns: \"No server technology information disclosed in headers - good security practice\"\n\n// Single exposure\nanalysis := &amp;ServerHeaderAnalysis{\n    total_exposures: 1,\n    technologies: []string{\"Cloudflare\"},\n}\ndesc := generateServerExposureDescription(analysis)\n// Returns: \"1 header exposes server information. Detected technologies: Cloudflare\"\n\n// Multiple exposures\nanalysis := &amp;ServerHeaderAnalysis{\n    total_exposures: 3,\n    technologies: []string{\"Apache\", \"PHP\", \"OpenSSL\"},\n}\ndesc := generateServerExposureDescription(analysis)\n// Returns: \"3 headers expose server information. Detected technologies: Apache, PHP, OpenSSL\"\n</code></pre> <p>Usage Context:</p> <p>These descriptions appear in:</p> <ul> <li>TestResult.Description field for test results</li> <li>CLI reporter output for console display</li> <li>Backend reporter API payloads</li> <li>Security audit reports</li> <li>Log files and monitoring systems</li> </ul> <p>Note:</p> <p>The description provides high-level summary information. Detailed header values and version information are available in the ServerHeaderAnalysis metadata structure.</p> <p></p>"},{"location":"App/Tests/#func-generatexcontenttypeoptionsdescription","title":"func generateXContentTypeOptionsDescription","text":"<pre><code>func generateXContentTypeOptionsDescription(metadata map[string]interface{}) string\n</code></pre> <p>generateXContentTypeOptionsDescription creates a human-readable description</p> <p></p>"},{"location":"App/Tests/#func-getsamesitestring","title":"func getSameSiteString","text":"<pre><code>func getSameSiteString(sameSite http.SameSite) string\n</code></pre> <p>getSameSiteString converts SameSite enum to string</p> <p></p>"},{"location":"App/Tests/#func-hasonlybroadsources","title":"func hasOnlyBroadSources","text":"<pre><code>func hasOnlyBroadSources(cspLower string) bool\n</code></pre> <p>hasOnlyBroadSources checks if the CSP frame-ancestors value contains only broad scheme sources (https:, http:, *) without specific domains. Values like \"https:\" alone allow all HTTPS sources, providing minimal real protection.</p> <p>Parameters:</p> <ul> <li>cspLower: Lowercase CSP frame-ancestors value</li> </ul> <p>Returns:</p> <ul> <li>bool: true if value only contains broad sources without specific domains</li> </ul> <p></p>"},{"location":"App/Tests/#func-hasspecificdomains","title":"func hasSpecificDomains","text":"<pre><code>func hasSpecificDomains(cspLower string) bool\n</code></pre> <p>hasSpecificDomains checks if the CSP frame-ancestors value contains specific domain restrictions (not just scheme sources, wildcards, or CSP keywords).</p> <p>Parameters:</p> <ul> <li>cspLower: Lowercase CSP frame-ancestors value</li> </ul> <p>Returns:</p> <ul> <li>bool: true if value contains at least one specific domain</li> </ul> <p></p>"},{"location":"App/Tests/#func-isallowlistrestricted","title":"func isAllowlistRestricted","text":"<pre><code>func isAllowlistRestricted(allowlist string) bool\n</code></pre> <p>isAllowlistRestricted determines if an allowlist value represents a restricted/safe configuration. According to the Permissions-Policy specification:</p> <ul> <li>\"()\" means disabled for all origins (restricted)</li> <li>\"(self)\" means allowed only for same-origin (restricted/safe)</li> <li>\"\" empty value means disabled (restricted)</li> <li>`(self \"https://example.com\" \"https://other.com\")` means allowed for self and specific origins (potentially dangerous), where additional origins must be quoted strings with full URLs</li> </ul> <p></p>"},{"location":"App/Tests/#func-ispredictablevalue","title":"func isPredictableValue","text":"<pre><code>func isPredictableValue(value string) bool\n</code></pre> <p>isPredictableValue checks if cookie value appears predictable</p> <p></p>"},{"location":"App/Tests/#func-issessioncookie","title":"func isSessionCookie","text":"<pre><code>func isSessionCookie(cookie *http.Cookie) bool\n</code></pre> <p>isSessionCookie determines if a cookie is likely a session cookie</p> <p></p>"},{"location":"App/Tests/#type-cspanalysis","title":"type CSPAnalysis","text":"<p>CSPAnalysis represents the parsed and analyzed CSP configuration</p> <pre><code>type CSPAnalysis struct {\n    HasCSP              bool                `json:\"hasCSP\"`\n    Directives          map[string][]string `json:\"directives\"`\n    SecurityIssues      []string            `json:\"securityIssues\"`\n    MissingDirectives   []string            `json:\"missingDirectives\"`\n    UnsafeDirectives    []string            `json:\"unsafeDirectives\"`\n    ProtectionLevel     string              `json:\"protectionLevel\"`\n    RecommendedActions  []string            `json:\"recommendedActions\"`\n    DirectiveCompliance map[string]string   `json:\"directiveCompliance\"`\n    PolicyStrength      int                 `json:\"policyStrength\"` // 0-100 score\n    CriticalVulns       []string            `json:\"criticalVulns\"`\n}\n</code></pre> <p></p>"},{"location":"App/Tests/#func-analyzecspheader","title":"func analyzeCSPHeader","text":"<pre><code>func analyzeCSPHeader(cspHeader string) CSPAnalysis\n</code></pre> <p>analyzeCSPHeader performs comprehensive analysis of the CSP header configuration</p> <p></p>"},{"location":"App/Tests/#type-cookiesecurityanalysis","title":"type CookieSecurityAnalysis","text":"<p>CookieSecurityAnalysis represents the comprehensive cookie security assessment</p> <pre><code>type CookieSecurityAnalysis struct {\n    TotalCookies         int                    `json:\"totalCookies\"`\n    CookieDetails        []CookieSecurityDetail `json:\"cookieDetails\"`\n    SecurityIssues       []string               `json:\"securityIssues\"`\n    CriticalIssues       []string               `json:\"criticalIssues\"`\n    MissingHttpOnly      int                    `json:\"missingHttpOnly\"`\n    MissingSecure        int                    `json:\"missingSecure\"`\n    MissingSameSite      int                    `json:\"missingSameSite\"`\n    LongExpiration       int                    `json:\"longExpiration\"`\n    SessionCookies       int                    `json:\"sessionCookies\"`\n    InsecureSession      bool                   `json:\"insecureSession\"`\n    FixationRisk         bool                   `json:\"fixationRisk\"`\n    OverallSecurityScore int                    `json:\"overallSecurityScore\"` // 0-100\n}\n</code></pre> <p></p>"},{"location":"App/Tests/#func-analyzecookiesecurity","title":"func analyzeCookieSecurity","text":"<pre><code>func analyzeCookieSecurity(cookies []*http.Cookie, headers http.Header) CookieSecurityAnalysis\n</code></pre> <p>analyzeCookieSecurity performs comprehensive analysis of all cookies</p> <p></p>"},{"location":"App/Tests/#type-cookiesecuritydetail","title":"type CookieSecurityDetail","text":"<p>CookieSecurityDetail represents security analysis for a single cookie</p> <pre><code>type CookieSecurityDetail struct {\n    Name             string   `json:\"name\"`\n    HasHttpOnly      bool     `json:\"hasHttpOnly\"`\n    HasSecure        bool     `json:\"hasSecure\"`\n    SameSite         string   `json:\"sameSite\"`\n    MaxAge           int      `json:\"maxAge\"`\n    ExpiresIn        string   `json:\"expiresIn\"`\n    IsSessionCookie  bool     `json:\"isSessionCookie\"`\n    SecurityIssues   []string `json:\"securityIssues\"`\n    SecurityScore    int      `json:\"securityScore\"` // 0-100\n    PredictableValue bool     `json:\"predictableValue\"`\n}\n</code></pre> <p></p>"},{"location":"App/Tests/#func-analyzesinglecookie","title":"func analyzeSingleCookie","text":"<pre><code>func analyzeSingleCookie(cookie *http.Cookie, setCookieHeaders []string, index int) CookieSecurityDetail\n</code></pre> <p>analyzeSingleCookie performs detailed security analysis of a single cookie</p> <p></p>"},{"location":"App/Tests/#type-crossoriginanalysis","title":"type CrossOriginAnalysis","text":"<p>CrossOriginAnalysis represents the parsed and analyzed cross-origin security headers configuration</p> <pre><code>type CrossOriginAnalysis struct {\n    HasCOEP            bool     `json:\"hasCOEP\"`\n    HasCORP            bool     `json:\"hasCORP\"`\n    HasCOOP            bool     `json:\"hasCOOP\"`\n    COEPValue          string   `json:\"coepValue\"`\n    CORPValue          string   `json:\"corpValue\"`\n    COOPValue          string   `json:\"coopValue\"`\n    SecurityIssues     []string `json:\"securityIssues\"`\n    ConfiguredHeaders  []string `json:\"configuredHeaders\"`\n    MissingHeaders     []string `json:\"missingHeaders\"`\n    ProtectionLevel    string   `json:\"protectionLevel\"`\n    RecommendedActions []string `json:\"recommendedActions\"`\n    IsolationEffective bool     `json:\"isolationEffective\"`\n}\n</code></pre> <p></p>"},{"location":"App/Tests/#type-jsobfuscationanalysis","title":"type JSObfuscationAnalysis","text":"<p>JSObfuscationAnalysis represents the comprehensive obfuscation analysis</p> <pre><code>type JSObfuscationAnalysis struct {\n    HasObfuscation      bool     `json:\"hasObfuscation\"`\n    ObfuscationScore    int      `json:\"obfuscationScore\"` // 0-100\n    ObfuscationPatterns []string `json:\"obfuscationPatterns\"`\n    SuspiciousPatterns  []string `json:\"suspiciousPatterns\"`\n    MaliciousIndicators []string `json:\"maliciousIndicators\"`\n    EncodingMethods     []string `json:\"encodingMethods\"`\n    DynamicExecution    int      `json:\"dynamicExecution\"` // Count of eval/Function calls\n    EncodedStrings      int      `json:\"encodedStrings\"`   // Count of encoded strings\n    CharCodeUsage       int      `json:\"charCodeUsage\"`    // String.fromCharCode usage\n    HexEscapes          int      `json:\"hexEscapes\"`       // \\x escape sequences\n    UnicodeEscapes      int      `json:\"unicodeEscapes\"`   // \\u escape sequences\n    Base64Strings       int      `json:\"base64Strings\"`    // Base64 encoded strings\n    ObfuscationLevel    string   `json:\"obfuscationLevel\"` // none, light, moderate, heavy, extreme\n    Certainty           int      `json:\"certainty\"`        // 0-100\n}\n</code></pre> <p></p>"},{"location":"App/Tests/#func-analyzejsobfuscation","title":"func analyzeJSObfuscation","text":"<pre><code>func analyzeJSObfuscation(content string) JSObfuscationAnalysis\n</code></pre> <p>analyzeJSObfuscation performs comprehensive JavaScript obfuscation analysis</p> <p></p>"},{"location":"App/Tests/#type-responsetest","title":"type ResponseTest","text":"<p>ResponseTest defines a security test that analyzes an HTTP response for vulnerabilities, misconfigurations, or security issues. It provides the structure and execution interface for all security tests in the framework.</p> <p>The structure uses composition with a function field for flexible test implementation:</p> <ul> <li>Allows inline test definition without separate structs</li> <li>Enables closure-based tests with captured context</li> <li>Simplifies test registration and discovery</li> <li>Supports both simple and complex test logic</li> </ul> <p>Each test should:</p> <ul> <li>Analyze specific security aspects (HTTPS, HSTS, headers, etc.)</li> <li>Return structured TestResult with appropriate ThreatLevel</li> <li>Include detailed Metadata for findings</li> <li>Provide actionable Description for remediation</li> </ul> <p>Fields:</p> <ul> <li>Id: Unique identifier for test registration and selection (e.g., \"https\", \"hsts\")</li> <li>Name: Human-readable test name for display</li> <li>Description: Detailed explanation of what the test checks</li> <li>RunTest: Function that executes the test logic</li> </ul> <pre><code>type ResponseTest struct {\n    Id          string                                     // Unique test identifier (e.g., \"https\", \"hsts\", \"csp\")\n    Name        string                                     // Human-readable test name\n    Description string                                     // Detailed test description\n    RunTest     func(params ResponseTestParams) TestResult // Test execution function\n}\n</code></pre> <p></p>"},{"location":"App/Tests/#func-newcsptest","title":"func NewCSPTest","text":"<pre><code>func NewCSPTest() *ResponseTest\n</code></pre> <p>NewCSPTest creates a new ResponseTest that analyzes Content Security Policy (CSP) header configuration. CSP is a security mechanism that helps prevent cross-site scripting (XSS), data injection attacks, and other code injection vulnerabilities by controlling which resources the browser is allowed to load for a given page.</p> <p>The test evaluates:</p> <ul> <li>Presence of Content-Security-Policy header</li> <li>Critical directive configurations (default-src, script-src, object-src, etc.)</li> <li>Unsafe directive values ('unsafe-inline', 'unsafe-eval', '*')</li> <li>Missing security-critical directives</li> <li>Policy syntax and validity</li> </ul> <p>Threat level assessment:</p> <ul> <li>None (0): Excellent - Comprehensive CSP with strict directives, no unsafe values</li> <li>Info (1): Good - Well-configured CSP with minor improvements possible</li> <li>Low (2): Acceptable - Basic CSP present with some weaknesses</li> <li>Medium (3): Weak - CSP present but with significant security issues</li> <li>High (4): Poor - CSP present but severely misconfigured or ineffective</li> <li>Critical (5): Missing - No CSP header found, vulnerable to injection attacks</li> </ul> <p>Security implications:</p> <ul> <li>Missing CSP: Vulnerable to XSS, data injection, and clickjacking attacks</li> <li>unsafe-inline: Allows inline scripts/styles, negating XSS protection</li> <li>unsafe-eval: Permits eval() and similar functions, enabling code injection</li> <li>Wildcard (*): Allows loading from any source, undermining security</li> <li>Missing object-src: May allow Flash/plugin-based attacks</li> <li>Missing base-uri: Vulnerable to base tag injection attacks</li> </ul> <p>Standards compliance:</p> <ul> <li>Content Security Policy Level 2 (W3C Recommendation)</li> <li>Content Security Policy Level 3 (W3C Working Draft)</li> </ul> <p>Returns:</p> <ul> <li>*ResponseTest: Configured CSP test ready for execution</li> </ul> <p>Example usage:</p> <pre><code>cspTest := NewCSPTest()\nresult := cspTest.Run(ResponseTestParams{Response: httpResponse})\n// Result includes threat level and detailed CSP configuration analysis\n</code></pre> <p></p>"},{"location":"App/Tests/#func-newcookiesecuritytest","title":"func NewCookieSecurityTest","text":"<pre><code>func NewCookieSecurityTest() *ResponseTest\n</code></pre> <p>NewCookieSecurityTest creates a new ResponseTest that analyzes cookie security configurations. Cookies are critical for session management and authentication, making their security paramount. Improperly configured cookies can lead to session hijacking, XSS exploitation, CSRF attacks, and session fixation vulnerabilities.</p> <p>The test evaluates:</p> <ul> <li>HttpOnly flag (prevents JavaScript access to cookies)</li> <li>Secure flag (ensures transmission only over HTTPS)</li> <li>SameSite attribute (protects against CSRF attacks)</li> <li>Expiration times (Max-Age/Expires values)</li> <li>Cookie predictability and session fixation risks</li> <li>Cookie name patterns indicating sensitive data</li> </ul> <p>Threat level assessment:</p> <ul> <li>None (0): All cookies properly secured with HttpOnly, Secure, SameSite, and reasonable expiration</li> <li>Info (1): Minor issues like long expiration times but critical flags present</li> <li>Low (2): Some cookies missing non-critical security attributes</li> <li>Medium (3): Cookies missing important security flags (HttpOnly or Secure)</li> <li>High (4): Multiple security issues or session cookies without protection</li> <li>Critical (5): Session cookies completely unsecured or high fixation risk</li> </ul> <p>Security implications:</p> <ul> <li>Missing HttpOnly: Vulnerable to XSS-based cookie theft</li> <li>Missing Secure: Cookies can be intercepted over HTTP (MITM attacks)</li> <li>Missing SameSite: Vulnerable to CSRF attacks</li> <li>Long expiration: Extended window for cookie theft/replay attacks</li> <li>Predictable values: Session fixation and prediction attacks</li> </ul> <p>Returns:</p> <ul> <li>*ResponseTest: Configured cookie security test ready for execution</li> </ul> <p>Example usage:</p> <pre><code>cookieTest := NewCookieSecurityTest()\nresult := cookieTest.Run(ResponseTestParams{Response: httpResponse})\n// Result includes threat level and detailed cookie security analysis\n</code></pre> <p></p>"},{"location":"App/Tests/#func-newcrossorigintest","title":"func NewCrossOriginTest","text":"<pre><code>func NewCrossOriginTest() *ResponseTest\n</code></pre> <p>NewCrossOriginTest creates a new ResponseTest that analyzes Cross-Origin security headers configuration. These headers provide defense-in-depth protection against cross-origin attacks, Spectre-like vulnerabilities, and help enforce browser-level isolation boundaries.</p> <p>The test evaluates:</p> <ul> <li>Cross-Origin-Embedder-Policy (COEP): Controls cross-origin resource embedding</li> <li>Cross-Origin-Resource-Policy (CORP): Controls cross-origin resource access</li> <li>Cross-Origin-Opener-Policy (COOP): Controls cross-origin window opener access</li> <li>Header value validation and security implications</li> <li>Combination effectiveness for comprehensive isolation</li> </ul> <p>Threat level assessment:</p> <ul> <li>None (0): Excellent - All three headers properly configured with strict values</li> <li>Info (1): Good - Two headers configured with secure values</li> <li>Low (2): Acceptable - One header configured or less strict configuration</li> <li>Medium (3): Weak - Headers present but with permissive values</li> <li>High (4): Poor - No cross-origin security headers found</li> </ul> <p>Security implications:</p> <ul> <li>Missing COEP: Vulnerable to cross-origin resource embedding attacks</li> <li>Missing CORP: Resources can be accessed cross-origin without restrictions</li> <li>Missing COOP: Vulnerable to cross-origin opener attacks and window references</li> <li>Permissive values: Reduced isolation effectiveness</li> <li>No headers: Full exposure to cross-origin attacks and Spectre-like vulnerabilities</li> </ul> <p>Standards compliance:</p> <ul> <li>Cross-Origin-Embedder-Policy (W3C Draft)</li> <li>Cross-Origin-Resource-Policy (W3C Recommendation)</li> <li>Cross-Origin-Opener-Policy (W3C Draft)</li> </ul> <p>Returns:</p> <ul> <li>*ResponseTest: Configured cross-origin security test ready for execution</li> </ul> <p>Example usage:</p> <pre><code>crossOriginTest := NewCrossOriginTest()\nresult := crossOriginTest.Run(ResponseTestParams{Response: httpResponse})\n// Result includes threat level and detailed cross-origin security analysis\n</code></pre> <p></p>"},{"location":"App/Tests/#func-newhststest","title":"func NewHSTSTest","text":"<pre><code>func NewHSTSTest() *ResponseTest\n</code></pre> <p>NewHSTSTest creates a new ResponseTest that analyzes HTTP Strict Transport Security (HSTS) header configuration. HSTS is a security mechanism that forces browsers to interact with websites exclusively over HTTPS, protecting against protocol downgrade attacks and cookie hijacking.</p> <p>The test evaluates:</p> <ul> <li>Presence of Strict-Transport-Security header</li> <li>max-age directive value (minimum recommended: 6 months, ideal: 1+ year)</li> <li>includeSubDomains directive (protects all subdomains)</li> <li>preload directive (enables HSTS preload list inclusion)</li> </ul> <p>Threat level assessment:</p> <ul> <li>None (0): Excellent - max-age \u2265 1 year + includeSubDomains + preload</li> <li>Info (1): Good - max-age \u2265 1 year + includeSubDomains</li> <li>Low (2): Acceptable - max-age \u2265 6 months</li> <li>Medium (3): Weak - max-age present but \\&lt; 6 months</li> <li>Medium (3): Missing - No HSTS header found</li> <li>High (4): Invalid - HSTS header present but missing/invalid max-age</li> </ul> <p>Security implications:</p> <ul> <li>Missing HSTS: Vulnerable to SSL stripping attacks, protocol downgrades, and MITM attacks</li> <li>Short max-age: Limited protection window, requires frequent policy refreshes</li> <li>No includeSubDomains: Subdomains remain vulnerable to attacks</li> <li>No preload: Not eligible for browser HSTS preload lists</li> </ul> <p>Returns:</p> <ul> <li>*ResponseTest: Configured HSTS test ready for execution</li> </ul> <p>Example usage:</p> <pre><code>hstsTest := NewHSTSTest()\nresult := hstsTest.Run(ResponseTestParams{Response: httpResponse})\n// Result includes threat level and detailed configuration analysis\n</code></pre> <p></p>"},{"location":"App/Tests/#func-newhttpstest","title":"func NewHTTPSTest","text":"<pre><code>func NewHTTPSTest() *ResponseTest\n</code></pre> <p>NewHTTPSTest creates a new security test that verifies HTTPS protocol usage. This test checks whether the target website enforces encrypted HTTPS connections or allows insecure HTTP communication.</p> <p>Test Behavior:</p> <p>The test examines the URL scheme of the HTTP response to determine the protocol:</p> <ul> <li>If scheme is \"https\": Returns ThreatLevel.None (secure)</li> <li>If scheme is \"http\": Returns ThreatLevel.High (insecure)</li> </ul> <p>Security Implications:</p> <p>HTTP connections transmit data in plaintext, making them vulnerable to:</p> <ul> <li>Packet sniffing and eavesdropping</li> <li>Man-in-the-middle (MITM) attacks</li> <li>Data tampering and injection</li> <li>Session hijacking</li> <li>Credential theft</li> </ul> <p>HTTPS provides:</p> <ul> <li>End-to-end encryption (TLS/SSL)</li> <li>Server authentication via certificates</li> <li>Data integrity verification</li> <li>Protection against passive and active attacks</li> </ul> <p>Certainty:</p> <p>This test always returns 100% certainty as protocol detection is deterministic based on the URL scheme in the HTTP response object.</p> <p>Returns:</p> <ul> <li>*ResponseTest: Configured test instance ready for execution</li> </ul> <p>Example:</p> <pre><code>// Create the HTTPS test\nhttpsTest := NewHTTPSTest()\n\n// Execute against target (via Runner)\nparams := ResponseTestParams{\n    Response: httpResponse,\n    Url:      \"https://example.com\",\n}\nresult := httpsTest.Run(params)\n\n// Secure site (HTTPS)\n// result.ThreatLevel = None\n// result.Description = \"Connection is secured with HTTPS protocol...\"\n\n// Insecure site (HTTP)\n// result.ThreatLevel = High\n// result.Description = \"Connection uses insecure HTTP protocol...\"\n</code></pre> <p>Related Tests:</p> <ul> <li>HSTSTest: Validates HTTP Strict Transport Security headers</li> <li>ServerHeaderTest: Analyzes server headers for security issues</li> </ul> <p></p>"},{"location":"App/Tests/#func-newjsobfuscationtest","title":"func NewJSObfuscationTest","text":"<pre><code>func NewJSObfuscationTest() *ResponseTest\n</code></pre> <p>NewJSObfuscationTest creates a new ResponseTest that analyzes JavaScript code for obfuscation. Obfuscated JavaScript is often used by attackers to hide malicious payloads, evade detection, or make reverse engineering difficult. While legitimate sites may use minification, heavy obfuscation is a red flag for potential security threats.</p> <p>The test evaluates:</p> <ul> <li>Encoded strings (Base64, hex, unicode escape sequences)</li> <li>Character substitution patterns</li> <li>Excessive use of eval(), Function(), or similar dynamic execution</li> <li>String concatenation obfuscation</li> <li>Highly compressed or minimized code patterns</li> <li>Suspicious variable/function naming patterns</li> <li>Code that decodes or decrypts itself at runtime</li> </ul> <p>Threat level assessment:</p> <ul> <li>None (0): No obfuscation detected, clean JavaScript code</li> <li>Info (1): Minor minification or basic optimization detected</li> <li>Low (2): Some obfuscation patterns but likely legitimate (e.g., webpack bundles)</li> <li>Medium (3): Moderate obfuscation with multiple suspicious patterns</li> <li>High (4): Heavy obfuscation with clear intent to hide functionality</li> <li>Critical (5): Extremely obfuscated code with malicious indicators</li> </ul> <p>Security implications:</p> <ul> <li>Obfuscated code can hide malicious payloads (keyloggers, data exfiltration)</li> <li>May indicate compromised website or injected malware</li> <li>Can evade security scanners and code review</li> <li>Often used in drive-by download attacks</li> <li>May hide cryptocurrency miners or ad fraud scripts</li> </ul> <p>Detection patterns:</p> <ul> <li>Base64 encoded strings followed by decode/atob</li> <li>Hex escape sequences (\\x41\\x42\\x43)</li> <li>Unicode escape sequences (\\u0041\\u0042\\u0043)</li> <li>eval() with encoded or constructed strings</li> <li>String.fromCharCode() with numeric arrays</li> <li>Excessive string concatenation</li> <li>Self-modifying or self-decrypting code</li> </ul> <p>Returns:</p> <ul> <li>*ResponseTest: Configured JavaScript obfuscation test ready for execution</li> </ul> <p>Example usage:</p> <pre><code>jsObfTest := NewJSObfuscationTest()\nresult := jsObfTest.Run(ResponseTestParams{Response: httpResponse})\n// Result includes threat level and detailed obfuscation analysis\n</code></pre> <p></p>"},{"location":"App/Tests/#func-newpermissionspolicytest","title":"func NewPermissionsPolicyTest","text":"<pre><code>func NewPermissionsPolicyTest() *ResponseTest\n</code></pre> <p>NewPermissionsPolicyTest creates a new ResponseTest that analyzes Permissions-Policy header configuration. The Permissions-Policy header controls which browser features and APIs can be used by the page and its embedded content, replacing the deprecated Feature-Policy.</p> <p>The test evaluates:</p> <ul> <li>Presence of Permissions-Policy header</li> <li>Dangerous permissions that should be restricted</li> <li>Overly permissive wildcard (*) usage</li> <li>Common security-sensitive features</li> </ul> <p>Threat level assessment:</p> <ul> <li>None (0): Excellent - Comprehensive policy with restricted dangerous features</li> <li>Info (1): Good - Policy present with minor issues</li> <li>Low (2): Acceptable - Basic policy with some unrestricted features</li> <li>Medium (3): Weak - Policy present but allows dangerous features</li> <li>High (4): Missing - No policy header found</li> </ul> <p>Security implications:</p> <ul> <li>Missing header: All features available to page and embedded content</li> <li>Unrestricted dangerous features: Risk of abuse (camera, microphone, geolocation)</li> <li>Wildcard usage: Overly permissive access to sensitive APIs</li> </ul> <p>Returns:</p> <ul> <li>*ResponseTest: Configured Permissions-Policy test ready for execution</li> </ul> <p></p>"},{"location":"App/Tests/#func-newreferrerpolicytest","title":"func NewReferrerPolicyTest","text":"<pre><code>func NewReferrerPolicyTest() *ResponseTest\n</code></pre> <p>NewReferrerPolicyTest creates a new ResponseTest that analyzes Referrer-Policy header configuration. The Referrer-Policy header controls how much referrer information (sent via the Referer header) should be included with requests made from your site. Proper configuration prevents information leakage and protects user privacy.</p> <p>The test evaluates:</p> <ul> <li>Presence of Referrer-Policy header</li> <li>Policy directive values and their security implications</li> <li>Multiple policy values and their precedence</li> <li>Insecure policy configurations</li> </ul> <p>Threat level assessment:</p> <ul> <li>None (0): Excellent - strict-origin-when-cross-origin, strict-origin, or no-referrer</li> <li>Info (1): Good - origin-when-cross-origin or origin</li> <li>Low (2): Acceptable - same-origin</li> <li>Medium (3): Weak - no-referrer-when-downgrade (default behavior)</li> <li>High (4): Vulnerable - unsafe-url or missing header with default behavior</li> </ul> <p>Security implications:</p> <ul> <li>Missing header: Uses browser default (typically no-referrer-when-downgrade)</li> <li>unsafe-url: Full URL sent as referrer to all origins (including HTTP)</li> <li>origin/origin-when-cross-origin: May leak origin information unnecessarily</li> <li>no-referrer: Maximum privacy but may break some functionality</li> <li>strict-origin-when-cross-origin: Recommended balance of security and functionality</li> </ul> <p>Policy values and security levels:</p> <ul> <li>no-referrer: Excellent - No referrer information sent</li> <li>no-referrer-when-downgrade: Medium - Default, leaks info on HTTPS\u2192HTTP</li> <li>origin: Info - Only origin sent, reasonable privacy</li> <li>origin-when-cross-origin: Info - Full URL for same-origin, origin for cross-origin</li> <li>same-origin: Low - Full URL for same-origin only</li> <li>strict-origin: Excellent - Origin only, no referrer on downgrade</li> <li>strict-origin-when-cross-origin: Excellent - Recommended by W3C</li> <li>unsafe-url: High - Always sends full URL (insecure)</li> </ul> <p>Returns:</p> <ul> <li>*ResponseTest: Configured Referrer-Policy test ready for execution</li> </ul> <p>Example usage:</p> <pre><code>referrerTest := NewReferrerPolicyTest()\nresult := referrerTest.Run(ResponseTestParams{Response: httpResponse})\n// Result includes threat level and detailed policy analysis\n</code></pre> <p></p>"},{"location":"App/Tests/#func-newserverheadertest","title":"func NewServerHeaderTest","text":"<pre><code>func NewServerHeaderTest() *ResponseTest\n</code></pre> <p>NewServerHeaderTest creates a new security test that analyzes HTTP response headers for server technology information disclosure vulnerabilities.</p> <p>This test examines 12 common HTTP headers that frequently expose sensitive information about the server technology stack, frameworks, and hosting infrastructure. It performs technology detection, version extraction, and CVE vulnerability assessment.</p> <p>Test Workflow:</p> <ol> <li>Extract Target Headers: Collect values from 12 predefined headers</li> <li>Analyze Headers: Identify exposed headers and detect technologies</li> <li>CVE Assessment: Query NIST NVD for known vulnerabilities</li> <li>Threat Evaluation: Calculate threat level based on exposure and CVEs</li> <li>Generate Report: Create human-readable description</li> </ol> <p>Detected Technologies:</p> <p>Web Servers:</p> <ul> <li>Apache, Nginx, Microsoft IIS, Cloudflare, Gunicorn, Uvicorn</li> </ul> <p>Application Frameworks:</p> <ul> <li>Express.js, Django, ASP.NET, PHP, Laravel, Ruby on Rails, Flask, Spring Framework</li> </ul> <p>Content Management Systems:</p> <ul> <li>Drupal, WordPress</li> </ul> <p>Infrastructure:</p> <ul> <li>Google PageSpeed, Varnish Cache, Dynamic Runtime</li> </ul> <p>Security Impact:</p> <p>Information disclosure enables:</p> <ul> <li>Vulnerability scanning with version-specific exploit databases</li> <li>Targeted attack preparation based on known weaknesses</li> <li>Technology stack fingerprinting</li> <li>Reduced attacker reconnaissance time</li> </ul> <p>The test assigns higher threat levels when:</p> <ul> <li>Multiple headers expose information (5+ = Medium)</li> <li>Technologies have known high-severity CVEs (Critical)</li> <li>Debug/test/dev indicators present (Critical)</li> <li>Common web servers revealed (High)</li> </ul> <p>Certainty:</p> <p>This test reports 95% certainty as header analysis is highly reliable, but some false positives may occur from customized or obfuscated headers.</p> <p>Returns:</p> <ul> <li>*ResponseTest: Configured test instance ready for execution</li> </ul> <p>Example:</p> <pre><code>// Create the server header test\nheaderTest := NewServerHeaderTest()\n\n// Execute against target (via Runner)\nparams := ResponseTestParams{\n    Response: httpResponse,\n    Url:      \"https://example.com\",\n}\nresult := headerTest.Run(params)\n\n// No exposure (secure)\n// result.ThreatLevel = None\n// result.Description = \"No server technology information disclosed...\"\n\n// Multiple exposures (insecure)\n// result.ThreatLevel = High\n// result.Description = \"5 headers expose server information. Detected: Apache/2.4.41, PHP/7.4.3...\"\n// result.Metadata = ServerHeaderAnalysis{...}\n</code></pre> <p>CVE Integration Example:</p> <pre><code>// If Apache 2.4.41 is detected and has known CVEs:\n// - Query NVD API for \"Apache\" vulnerabilities\n// - Assess severity levels (High/Medium/Low)\n// - Elevate threat level to Critical if high-severity CVEs found\n</code></pre> <p>Related Tests:</p> <ul> <li>HTTPSTest: Validates encrypted connections</li> <li>HSTSTest: Checks HTTP Strict Transport Security enforcement</li> </ul> <p></p>"},{"location":"App/Tests/#func-newxcontenttypeoptionstest","title":"func NewXContentTypeOptionsTest","text":"<pre><code>func NewXContentTypeOptionsTest() *ResponseTest\n</code></pre> <p>NewXContentTypeOptionsTest creates a new ResponseTest that analyzes X-Content-Type-Options header configuration. The X-Content-Type-Options header prevents browsers from MIME-sniffing a response away from the declared content-type, which helps prevent XSS attacks and other security issues.</p> <p>The test evaluates:</p> <ul> <li>Presence of X-Content-Type-Options header</li> <li>Correct \"nosniff\" directive value</li> <li>Case sensitivity and formatting</li> </ul> <p>Threat level assessment:</p> <ul> <li>None (0): Excellent - X-Content-Type-Options: nosniff properly configured</li> <li>High (4): Missing - No header found, vulnerable to MIME sniffing attacks</li> <li>Medium (3): Invalid - Header present but with incorrect value</li> </ul> <p>Security implications:</p> <ul> <li>Missing header: Browsers may MIME-sniff content leading to XSS vulnerabilities</li> <li>Invalid value: Header ignored by browsers, same risk as missing</li> <li>Correct \"nosniff\": Prevents MIME type sniffing attacks</li> </ul> <p>Returns:</p> <ul> <li>*ResponseTest: Configured X-Content-Type-Options test ready for execution</li> </ul> <p></p>"},{"location":"App/Tests/#func-newxframetest","title":"func NewXFrameTest","text":"<pre><code>func NewXFrameTest() *ResponseTest\n</code></pre> <p>NewXFrameTest creates a new ResponseTest that analyzes X-Frame-Options header and CSP frame directives to assess clickjacking protection. Clickjacking attacks embed target pages in iframes to trick users into performing unintended actions on the embedded content.</p> <p>The test evaluates:</p> <ul> <li>Presence of X-Frame-Options header (legacy protection)</li> <li>X-Frame-Options directive values (DENY, SAMEORIGIN, ALLOW-FROM)</li> <li>Content-Security-Policy frame-ancestors directive (modern protection)</li> <li>Conflicting or invalid configurations</li> </ul> <p>Threat level assessment:</p> <ul> <li>None (0): Excellent - CSP frame-ancestors 'none' or X-Frame-Options DENY</li> <li>Info (1): Good - CSP frame-ancestors 'self' or X-Frame-Options SAMEORIGIN</li> <li>Low (2): Limited - X-Frame-Options ALLOW-FROM (deprecated and limited browser support)</li> <li>Medium (3): Weak - Only CSP frame-ancestors with specific domains (partial protection)</li> <li>High (4): Vulnerable - Missing both X-Frame-Options and CSP frame-ancestors</li> <li>High (4): Invalid - Present but with invalid/malformed directives</li> </ul> <p>Security implications:</p> <ul> <li>Missing protection: Vulnerable to clickjacking attacks, UI redressing, and iframe abuse</li> <li>ALLOW-FROM directive: Deprecated and not supported in modern browsers</li> <li>Conflicting headers: May lead to inconsistent protection across browsers</li> <li>Invalid values: Browsers may ignore protection, leaving site vulnerable</li> </ul> <p>Standards compliance:</p> <ul> <li>X-Frame-Options: RFC 7034 (legacy, but widely supported)</li> <li>CSP frame-ancestors: CSP Level 2 (modern, preferred approach)</li> </ul> <p>Returns:</p> <ul> <li>*ResponseTest: Configured X-Frame-Options test ready for execution</li> </ul> <p>Example usage:</p> <pre><code>xframeTest := NewXFrameTest()\nresult := xframeTest.Run(ResponseTestParams{Response: httpResponse})\n// Result includes threat level and detailed iframe embedding analysis\n</code></pre> <p></p>"},{"location":"App/Tests/#func-responsetest-getdescription","title":"func (*ResponseTest) GetDescription","text":"<pre><code>func (brt *ResponseTest) GetDescription() string\n</code></pre> <p>GetDescription returns the detailed description of what the test analyzes. This method provides read-only access to the test's purpose and functionality.</p> <p>Returns:</p> <ul> <li>string: The test's detailed description</li> </ul> <p></p>"},{"location":"App/Tests/#func-responsetest-getid","title":"func (*ResponseTest) GetId","text":"<pre><code>func (brt *ResponseTest) GetId() string\n</code></pre> <p>GetId returns the unique identifier of the test used for registration and lookup. This method provides read-only access to the test's ID.</p> <p>Returns:</p> <ul> <li>string: The test's unique identifier</li> </ul> <p></p>"},{"location":"App/Tests/#func-responsetest-getname","title":"func (*ResponseTest) GetName","text":"<pre><code>func (brt *ResponseTest) GetName() string\n</code></pre> <p>GetName returns the human-readable name of the test for display purposes. This method provides read-only access to the test's display name.</p> <p>Returns:</p> <ul> <li>string: The test's display name</li> </ul> <p></p>"},{"location":"App/Tests/#func-responsetest-run","title":"func (*ResponseTest) Run","text":"<pre><code>func (rt *ResponseTest) Run(params ResponseTestParams) TestResult\n</code></pre> <p>Run executes the test logic against the provided HTTP response parameters and returns the security analysis results. This is the main entry point for test execution.</p> <p>The method validates that RunTest is implemented before execution and panics if not, ensuring tests are properly configured before use.</p> <p>Parameters:</p> <ul> <li>params: ResponseTestParams containing the HTTP response to analyze</li> </ul> <p>Returns:</p> <ul> <li>TestResult: Structured results including threat level and findings</li> </ul> <p>Panics:</p> <ul> <li>string: \"Run method not implemented\" if RunTest function is nil</li> </ul> <p>Example:</p> <pre><code>test := NewHTTPSTest()\nparams := ResponseTestParams{Response: httpResponse}\nresult := test.Run(params)\nfmt.Printf(\"Threat Level: %v\\n\", result.ThreatLevel)\n</code></pre> <p></p>"},{"location":"App/Tests/#type-responsetestparams","title":"type ResponseTestParams","text":"<p>ResponseTestParams encapsulates the parameters passed to a ResponseTest for execution. It provides the HTTP response object that tests analyze to detect security issues, misconfigurations, and vulnerabilities.</p> <p>The structure enables:</p> <ul> <li>Clean test interface with extensibility</li> <li>Sharing of HTTP response across multiple tests</li> <li>Future addition of context or configuration parameters</li> </ul> <p>The Response object contains:</p> <ul> <li>HTTP headers (security headers, server information, etc.)</li> <li>Status code</li> <li>Request details (URL, method, original request)</li> <li>Body content (if read by test)</li> </ul> <pre><code>type ResponseTestParams struct {\n    Response *http.Response // HTTP response to analyze for security issues\n}\n</code></pre> <p></p>"},{"location":"App/Tests/#type-serverheaderanalysis","title":"type ServerHeaderAnalysis","text":"<p>ServerHeaderAnalysis represents the comprehensive analysis results of HTTP headers for server technology information disclosure.</p> <p>This structure aggregates data about exposed headers, detected technologies, and their potential security implications. It serves as metadata for test results and provides detailed insights for security reporting.</p> <p>Fields:</p> <ul> <li>exposed_headers: List of header names that revealed information</li> <li>technologies: Detected technology stack components (deduplicated)</li> <li>total_exposures: Count of headers exposing information</li> <li>header_details: Map of header names to their actual values</li> <li>technology_stack: Map of detected technologies to their versions</li> </ul> <p>Example structure:</p> <pre><code>{\n    exposed_headers: [\"Server\", \"X-Powered-By\"],\n    technologies: [\"Nginx\", \"PHP\"],\n    total_exposures: 2,\n    header_details: {\n        \"Server\": \"nginx/1.18.0\",\n        \"X-Powered-By\": \"PHP/7.4.3\"\n    },\n    technology_stack: {\n        \"Nginx\": \"1.18.0\",\n        \"PHP\": \"7.4.3\"\n    }\n}\n</code></pre> <pre><code>type ServerHeaderAnalysis struct {\n    exposed_headers  []string\n    technologies     []string\n    total_exposures  int\n    header_details   map[string]string\n    technology_stack map[string]string\n}\n</code></pre> <p></p>"},{"location":"App/Tests/#func-analyzeserverheaders","title":"func analyzeServerHeaders","text":"<pre><code>func analyzeServerHeaders(headers map[string]string) *ServerHeaderAnalysis\n</code></pre> <p>analyzeServerHeaders examines HTTP headers for technology disclosure patterns and constructs a comprehensive analysis of exposed information.</p> <p>This function processes the collected headers to identify:</p> <ul> <li>Which headers expose information</li> <li>What technologies are revealed</li> <li>Version information when available</li> <li>Overall exposure count</li> </ul> <p>The analysis involves:</p> <ol> <li>Filtering out empty headers</li> <li>Recording exposed header names</li> <li>Detecting technologies from header values</li> <li>Extracting version information</li> <li>Building technology stack mapping</li> <li>Deduplicating technology entries</li> </ol> <p>Technology Detection:</p> <p>For each non-empty header, the function calls detectTechnologies() which uses pattern matching to identify specific software, frameworks, and services.</p> <p>Parameters:</p> <ul> <li>headers: Map of header names to their values from HTTP response</li> </ul> <p>Returns:</p> <ul> <li>*ServerHeaderAnalysis: Comprehensive analysis structure with:</li> <li>exposed_headers: List of header names containing information</li> <li>technologies: Deduplicated list of detected technologies</li> <li>total_exposures: Count of exposed headers</li> <li>header_details: Original header name-value pairs</li> <li>technology_stack: Technology-to-version mapping</li> </ul> <p>Example:</p> <pre><code>headers := map[string]string{\n    \"Server\": \"nginx/1.18.0\",\n    \"X-Powered-By\": \"PHP/7.4.3\",\n    \"X-Cache\": \"\",  // Empty, will be filtered\n}\n\nanalysis := analyzeServerHeaders(headers)\n// analysis.exposed_headers = [\"Server\", \"X-Powered-By\"]\n// analysis.technologies = [\"Nginx\", \"PHP\"]\n// analysis.total_exposures = 2\n// analysis.technology_stack = {\"Nginx\": \"1.18.0\", \"PHP\": \"7.4.3\"}\n</code></pre> <p></p>"},{"location":"App/Tests/#type-testresult","title":"type TestResult","text":"<p>TestResult represents the comprehensive output of a security test execution. It encapsulates all information about the test findings including classification, confidence level, detailed metadata, and human-readable descriptions.</p> <p>The structure is designed for:</p> <ul> <li>JSON serialization for API reporting</li> <li>Human-readable console output</li> <li>Automated processing and aggregation</li> <li>Detailed forensic analysis</li> </ul> <p>Fields provide multiple levels of detail:</p> <ul> <li>Name: Test identifier for categorization</li> <li>Certainty: Confidence percentage (0-100) in the finding</li> <li>ThreatLevel: Security classification (None to Critical)</li> <li>Metadata: Test-specific data (headers, configurations, CVEs, etc.)</li> <li>Description: Human-readable explanation of findings</li> </ul> <pre><code>type TestResult struct {\n    Name        string      `json:\"Name\"`        // Test name for identification\n    Certainty   int         `json:\"Certainty\"`   // Confidence percentage (0-100)\n    ThreatLevel ThreatLevel `json:\"ThreatLevel\"` // Security threat classification\n    Metadata    any         `json:\"Metadata\"`    // Test-specific detailed data\n    Description string      `json:\"Description\"` // Human-readable findings explanation\n}\n</code></pre> <p></p>"},{"location":"App/Tests/#type-testresultwrapper","title":"type TestResultWrapper","text":"<p>TestResultWrapper represents fully structured response sent to the backend Fields:</p> <ul> <li>Target: Given target</li> <li>TestId: id related to full scan</li> <li>Result: Core data of test</li> <li>EndFlag: Check if engine finished its job</li> </ul> <pre><code>type TestResultWrapper struct {\n    Target  string     `json:\"target\"`\n    TestId  string     `json:\"testId\"`\n    Result  TestResult `json:\"result\"`\n    EndFlag bool       `json:\"endFlag\"`\n}\n</code></pre> <p></p>"},{"location":"App/Tests/#type-threatlevel","title":"type ThreatLevel","text":"<p>ThreatLevel represents the security threat classification for test results. It provides a standardized scale from None (no threat) to Critical (severe vulnerability) aligned with industry security standards and risk assessment frameworks.</p> <p>The enumeration enables:</p> <ul> <li>Consistent threat classification across all tests</li> <li>Priority-based vulnerability triage</li> <li>Risk-based decision making</li> <li>Compliance with security reporting standards</li> </ul> <pre><code>type ThreatLevel int\n</code></pre> <p>ThreatLevel enumeration constants representing increasing levels of security concern. These levels align with CVSS severity ratings and common security frameworks.</p> <p>Level definitions:</p> <ul> <li>None (0): No security issues detected, configuration meets best practices</li> <li>Info (1): Informational findings, no immediate security impact</li> <li>Low (2): Minor security issues with low exploitability or impact</li> <li>Medium (3): Moderate security concerns requiring attention</li> <li>High (4): Serious vulnerabilities with significant security impact</li> <li>Critical (5): Severe vulnerabilities requiring immediate remediation</li> </ul> <pre><code>const (\n    None     ThreatLevel = iota // 0 - No security issues\n    Info                        // 1 - Informational findings\n    Low                         // 2 - Low severity issues\n    Medium                      // 3 - Medium severity issues\n    High                        // 4 - High severity vulnerabilities\n    Critical                    // 5 - Critical vulnerabilities\n)\n</code></pre> <p></p>"},{"location":"App/Tests/#func-evaluatecspthreatlevel","title":"func evaluateCSPThreatLevel","text":"<pre><code>func evaluateCSPThreatLevel(analysis CSPAnalysis) ThreatLevel\n</code></pre> <p>evaluateCSPThreatLevel determines the threat level based on CSP analysis</p> <p></p>"},{"location":"App/Tests/#func-evaluatecookiethreatlevel","title":"func evaluateCookieThreatLevel","text":"<pre><code>func evaluateCookieThreatLevel(analysis CookieSecurityAnalysis) ThreatLevel\n</code></pre> <p>evaluateCookieThreatLevel determines threat level based on analysis</p> <p></p>"},{"location":"App/Tests/#func-evaluatecrossoriginthreatlevel","title":"func evaluateCrossOriginThreatLevel","text":"<pre><code>func evaluateCrossOriginThreatLevel(metadata map[string]interface{}) ThreatLevel\n</code></pre> <p>evaluateCrossOriginThreatLevel determines the security threat level based on cross-origin headers configuration and their security implications.</p> <p>Parameters:</p> <ul> <li>metadata: Analyzed cross-origin headers metadata</li> </ul> <p>Returns:</p> <ul> <li>ThreatLevel: Security threat level based on configuration</li> </ul> <p></p>"},{"location":"App/Tests/#func-evaluatehststhreatlevel","title":"func evaluateHSTSThreatLevel","text":"<pre><code>func evaluateHSTSThreatLevel(metadata map[string]interface{}) ThreatLevel\n</code></pre> <p>evaluateHSTSThreatLevel determines the security threat level based on HSTS configuration quality. It applies industry best practices and security standards to classify the HSTS implementation strength.</p> <p>Threat level classification:</p> <ul> <li> <p>None (0): Excellent configuration</p> </li> <li> <p>max-age \u2265 1 year (31,536,000 seconds)</p> </li> <li> <p>includeSubDomains present</p> </li> <li> <p>preload present</p> </li> <li> <p>Meets HSTS preload list requirements</p> </li> <li> <p>Maximum protection against protocol downgrade attacks</p> </li> <li> <p>Info (1): Good configuration</p> </li> <li> <p>max-age \u2265 1 year</p> </li> <li> <p>includeSubDomains present</p> </li> <li> <p>Strong protection, but not preload-eligible</p> </li> <li> <p>Low (2): Acceptable configuration</p> </li> <li> <p>max-age \u2265 6 months (15,552,000 seconds)</p> </li> <li> <p>Provides reasonable protection</p> </li> <li> <p>Should consider increasing max-age</p> </li> <li> <p>Medium (3): Weak configuration</p> </li> <li> <p>max-age present but \\&lt; 6 months</p> </li> <li> <p>Limited protection window</p> </li> <li> <p>Requires frequent policy refreshes</p> </li> <li> <p>Vulnerable during gaps</p> </li> <li> <p>High (4): Invalid or critically weak</p> </li> <li> <p>max-age = 0 or missing</p> </li> <li> <p>HSTS effectively disabled</p> </li> <li> <p>No protection against protocol downgrades</p> </li> </ul> <p>Security standards reference:</p> <ul> <li>OWASP recommends minimum max-age of 1 year</li> <li>HSTS preload list requires: max-age \u2265 1 year + includeSubDomains + preload</li> <li>RFC 6797 specifies HSTS behavior and directives</li> </ul> <p>Parameters:</p> <ul> <li>metadata: Parsed HSTS header metadata from analyzeHSTSHeader</li> </ul> <p>Returns:</p> <ul> <li>ThreatLevel: Security classification (None, Info, Low, Medium, or High)</li> </ul> <p>Example:</p> <pre><code>metadata := map[string]interface{}{\n    \"max_age\": 31536000,\n    \"include_subdomains\": true,\n    \"preload\": true,\n}\nlevel := evaluateHSTSThreatLevel(metadata)  // Returns: None (Excellent)\n</code></pre> <p></p>"},{"location":"App/Tests/#func-evaluateobfuscationthreat","title":"func evaluateObfuscationThreat","text":"<pre><code>func evaluateObfuscationThreat(analysis JSObfuscationAnalysis) ThreatLevel\n</code></pre> <p>evaluateObfuscationThreat determines threat level</p> <p></p>"},{"location":"App/Tests/#func-evaluatepermissionspolicythreatlevel","title":"func evaluatePermissionsPolicyThreatLevel","text":"<pre><code>func evaluatePermissionsPolicyThreatLevel(metadata map[string]interface{}) ThreatLevel\n</code></pre> <p>evaluatePermissionsPolicyThreatLevel determines the security threat level based on Permissions-Policy configuration.</p> <p></p>"},{"location":"App/Tests/#func-evaluatereferrerpolicythreatlevel","title":"func evaluateReferrerPolicyThreatLevel","text":"<pre><code>func evaluateReferrerPolicyThreatLevel(metadata map[string]interface{}) ThreatLevel\n</code></pre> <p>evaluateReferrerPolicyThreatLevel determines the security threat level based on Referrer-Policy configuration quality. It applies privacy and security best practices to classify the referrer policy implementation strength.</p> <p>Threat level classification:</p> <ul> <li> <p>None (0): Excellent configuration</p> </li> <li> <p>strict-origin-when-cross-origin (W3C recommended)</p> </li> <li> <p>strict-origin (strong privacy)</p> </li> <li> <p>no-referrer (maximum privacy)</p> </li> <li> <p>Info (1): Good configuration</p> </li> <li> <p>origin-when-cross-origin (reasonable balance)</p> </li> <li> <p>origin (basic privacy protection)</p> </li> <li> <p>Low (2): Acceptable configuration</p> </li> <li> <p>same-origin (limited privacy protection)</p> </li> <li> <p>Medium (3): Weak configuration</p> </li> <li> <p>no-referrer-when-downgrade (browser default)</p> </li> <li> <p>Multiple conflicting policies</p> </li> <li> <p>Configurations relying solely on browser default behavior</p> </li> <li> <p>High (4): Vulnerable configuration</p> </li> <li> <p>unsafe-url (always sends full URL)</p> </li> <li> <p>Invalid/unrecognized policies only</p> </li> <li> <p>Malformed header</p> </li> </ul> <p>The assessment considers:</p> <ul> <li>Privacy protection level</li> <li>Information leakage potential</li> <li>Cross-origin data exposure</li> <li>Protocol downgrade behavior</li> <li>Policy conflicts and precedence</li> </ul> <p>Parameters:</p> <ul> <li>metadata: Parsed referrer policy metadata from analyzeReferrerPolicyHeader</li> </ul> <p>Returns:</p> <ul> <li>ThreatLevel: Security classification (None, Info, Low, Medium, or High)</li> </ul> <p>Example:</p> <pre><code>metadata := map[string]interface{}{\n    \"effective_policy\": \"strict-origin-when-cross-origin\",\n    \"has_unsafe\": false,\n}\nlevel := evaluateReferrerPolicyThreatLevel(metadata)\n// Returns: None (excellent configuration)\n</code></pre> <p></p>"},{"location":"App/Tests/#func-evaluateserverexposurethreatlevel","title":"func evaluateServerExposureThreatLevel","text":"<pre><code>func evaluateServerExposureThreatLevel(analysis *ServerHeaderAnalysis) ThreatLevel\n</code></pre> <p>evaluateServerExposureThreatLevel calculates the security threat level based on server header information disclosure and known vulnerabilities.</p> <p>This function implements a sophisticated threat assessment algorithm that combines:</p> <ul> <li>Quantitative exposure analysis (number of headers revealing information)</li> <li>CVE vulnerability assessment from NIST NVD database</li> <li>Heuristic pattern matching for high-risk configurations</li> </ul> <p>Three-Layer Assessment:</p> <p>Layer 1: Base Threat (Exposure Count)</p> <ul> <li>0 exposures \u2192 None: No information disclosed</li> <li>1-2 exposures \u2192 Info: Minimal disclosure</li> <li>3-4 exposures \u2192 Low: Moderate disclosure</li> <li>5+ exposures \u2192 Medium: Extensive disclosure</li> </ul> <p>Layer 2: CVE Enhancement (Vulnerability Database)</p> <ul> <li>Query NIST NVD for each detected technology</li> <li>Assess CVE severity levels (High/Medium/Low)</li> <li>Map CVE severity to threat levels:</li> <li>High severity CVE present \u2192 Critical</li> <li>6+ medium severity CVEs \u2192 High</li> <li>1-5 medium severity CVEs \u2192 Medium</li> <li>11+ low severity CVEs \u2192 Medium</li> <li>1-10 low severity CVEs \u2192 Low</li> </ul> <p>Layer 3: Heuristic Enhancement (Risk Patterns)</p> <ul> <li>Debug/test/dev identifiers \u2192 Critical</li> <li>Common web servers (Apache/Nginx/IIS) \u2192 High</li> </ul> <p>Priority Logic:</p> <p>The function uses maximum threat level logic - if any layer identifies a higher threat, that level becomes the final assessment. This ensures critical vulnerabilities are never downgraded.</p> <p>CVE Integration:</p> <p>For each detected technology, the function:</p> <ol> <li>Creates CVE client instance</li> <li>Queries NIST NVD API with technology name</li> <li>Receives vulnerability assessment with severity counts</li> <li>Maps CVE severity to our ThreatLevel enum</li> <li>Updates threat level if higher than current assessment</li> </ol> <p>Parameters:</p> <ul> <li>analysis: ServerHeaderAnalysis containing exposure and technology data</li> </ul> <p>Returns:</p> <ul> <li>ThreatLevel: Final calculated threat level (None/Info/Low/Medium/High/Critical)</li> </ul> <p>Example:</p> <pre><code>// Minimal exposure, no CVEs\nanalysis := &amp;ServerHeaderAnalysis{\n    total_exposures: 1,\n    technologies: []string{\"Cloudflare\"},\n}\nlevel := evaluateServerExposureThreatLevel(analysis)\n// Returns: Info\n\n// Multiple exposures with vulnerable technology\nanalysis := &amp;ServerHeaderAnalysis{\n    total_exposures: 5,\n    technologies: []string{\"Apache\", \"PHP\"},  // Has known CVEs\n}\nlevel := evaluateServerExposureThreatLevel(analysis)\n// Returns: Critical (due to CVE assessment)\n\n// Debug environment exposed\nanalysis := &amp;ServerHeaderAnalysis{\n    total_exposures: 2,\n    technologies: []string{\"Express-debug\"},\n}\nlevel := evaluateServerExposureThreatLevel(analysis)\n// Returns: Critical (heuristic match)\n</code></pre> <p>Security Context:</p> <p>The threat level indicates:</p> <ul> <li>Critical: Immediate remediation required (CVE High or debug exposed)</li> <li>High: Significant risk (common servers or multiple medium CVEs)</li> <li>Medium: Moderate risk (multiple exposures or some CVEs)</li> <li>Low: Minor risk (few exposures, low-severity CVEs)</li> <li>Info: Informational (minimal exposure, no vulnerabilities)</li> <li>None: Secure configuration (no disclosure)</li> </ul> <p></p>"},{"location":"App/Tests/#func-evaluatexcontenttypeoptionsthreatlevel","title":"func evaluateXContentTypeOptionsThreatLevel","text":"<pre><code>func evaluateXContentTypeOptionsThreatLevel(metadata map[string]interface{}) ThreatLevel\n</code></pre> <p>evaluateXContentTypeOptionsThreatLevel determines the security threat level</p> <p></p>"},{"location":"App/Tests/#func-mapcvethreatlevel","title":"func mapCVEThreatLevel","text":"<pre><code>func mapCVEThreatLevel(assessment CVE.VulnerabilityAssessment) ThreatLevel\n</code></pre> <p>mapCVEThreatLevel maps CVE vulnerability assessment results from the NIST NVD database to the Engine-AntiGinx ThreatLevel enumeration.</p> <p>This function translates CVSS (Common Vulnerability Scoring System) severity classifications into our internal threat level system, enabling consistent risk assessment across different vulnerability sources.</p> <p>CVSS to ThreatLevel Mapping:</p> <p>High Severity CVEs:</p> <ul> <li>Any high-severity vulnerability \u2192 Critical</li> <li>Rationale: High-severity CVEs (CVSS 7.0-10.0) indicate serious vulnerabilities requiring immediate attention</li> </ul> <p>Medium Severity CVEs:</p> <ul> <li>6+ medium-severity vulnerabilities \u2192 High</li> <li>1-5 medium-severity vulnerabilities \u2192 Medium</li> <li>Rationale: Multiple medium vulnerabilities (CVSS 4.0-6.9) compound risk and warrant elevated threat levels</li> </ul> <p>Low Severity CVEs:</p> <ul> <li>11+ low-severity vulnerabilities \u2192 Medium</li> <li>1-10 low-severity vulnerabilities \u2192 Low</li> <li>Rationale: Large numbers of low-severity issues (CVSS 0.1-3.9) indicate poor maintenance and potential security debt</li> </ul> <p>No Vulnerabilities:</p> <ul> <li>CVE count &gt; 0 but no severity classified \u2192 Info</li> <li>CVE count = 0 \u2192 None</li> <li>Rationale: Presence in CVE database warrants awareness</li> </ul> <p>Priority Logic:</p> <p>The function uses a cascading if-else structure that prioritizes higher severity findings. Once a match is found, lower severity checks are skipped.</p> <p>Parameters:</p> <ul> <li>assessment: VulnerabilityAssessment structure from CVE client containing:</li> <li>CVECount: Total number of CVEs found</li> <li>HighSeverity: Count of high-severity vulnerabilities</li> <li>MediumSeverity: Count of medium-severity vulnerabilities</li> <li>LowSeverity: Count of low-severity vulnerabilities</li> </ul> <p>Returns:</p> <ul> <li>ThreatLevel: Mapped threat level (None/Info/Low/Medium/High/Critical)</li> </ul> <p>Example:</p> <pre><code>// High severity vulnerability present\nassessment := CVE.VulnerabilityAssessment{\n    CVECount: 8,\n    HighSeverity: 2,\n    MediumSeverity: 4,\n    LowSeverity: 2,\n}\nlevel := mapCVEThreatLevel(assessment)\n// Returns: Critical\n\n// Multiple medium severity vulnerabilities\nassessment := CVE.VulnerabilityAssessment{\n    CVECount: 7,\n    HighSeverity: 0,\n    MediumSeverity: 7,\n    LowSeverity: 0,\n}\nlevel := mapCVEThreatLevel(assessment)\n// Returns: High\n\n// Many low severity vulnerabilities\nassessment := CVE.VulnerabilityAssessment{\n    CVECount: 15,\n    HighSeverity: 0,\n    MediumSeverity: 0,\n    LowSeverity: 15,\n}\nlevel := mapCVEThreatLevel(assessment)\n// Returns: Medium\n\n// No vulnerabilities found\nassessment := CVE.VulnerabilityAssessment{\n    CVECount: 0,\n    HighSeverity: 0,\n    MediumSeverity: 0,\n    LowSeverity: 0,\n}\nlevel := mapCVEThreatLevel(assessment)\n// Returns: None\n</code></pre> <p>Security Standards Alignment:</p> <p>CVSS Severity Ranges:</p> <ul> <li>None: 0.0</li> <li>Low: 0.1-3.9</li> <li>Medium: 4.0-6.9</li> <li>High: 7.0-8.9</li> <li>Critical: 9.0-10.0</li> </ul> <p>Related Functions:</p> <ul> <li>evaluateServerExposureThreatLevel(): Uses this function for CVE assessment</li> <li>CVE.AssessTechnologyVulnerabilities(): Provides assessment data</li> </ul> <p></p>"},{"location":"App/Tests/#func-threatlevel-marshaljson","title":"func (ThreatLevel) MarshalJSON","text":"<pre><code>func (t ThreatLevel) MarshalJSON() ([]byte, error)\n</code></pre> <p>MarshalJSON implements custom JSON marshaling for ThreatLevel, converting the enumeration value to its string representation in JSON output. This ensures human-readable JSON instead of numeric values.</p> <p>Without this method, ThreatLevel would serialize as integers (0, 1, 2, etc.). With this method, it serializes as strings (\"None\", \"Info\", \"Low\", etc.).</p> <p>This is particularly important for:</p> <ul> <li>API responses that need to be human-readable</li> <li>Log files and reports</li> <li>Integration with external systems expecting string values</li> <li>Debugging and analysis</li> </ul> <p>Returns:</p> <ul> <li>[]byte: JSON-encoded string representation of the threat level</li> <li>error: Error from JSON marshaling (typically nil)</li> </ul> <p>Example:</p> <pre><code>result := TestResult{\n    Name: \"HTTPS Test\",\n    ThreatLevel: High,\n}\njsonData, _ := json.Marshal(result)\n// Output includes: \"ThreatLevel\": \"High\" (not \"ThreatLevel\": 4)\n</code></pre> <p></p>"},{"location":"App/Tests/#func-threatlevel-string","title":"func (ThreatLevel) String","text":"<pre><code>func (t ThreatLevel) String() string\n</code></pre> <p>String converts a ThreatLevel value to its human-readable string representation. This method implements the Stringer interface enabling automatic string conversion for logging, display, and debugging purposes.</p> <p>String representations:</p> <ul> <li>None (0) \u2192 \"None\"</li> <li>Info (1) \u2192 \"Info\"</li> <li>Low (2) \u2192 \"Low\"</li> <li>Medium (3) \u2192 \"Medium\"</li> <li>High (4) \u2192 \"High\"</li> <li>Critical (5) \u2192 \"Critical\"</li> </ul> <p>Returns:</p> <ul> <li>string: Human-readable threat level name</li> </ul> <p>Panics:</p> <ul> <li>Errors.Error: If the ThreatLevel value is invalid/unknown</li> </ul> <p>Example:</p> <pre><code>level := High\nfmt.Println(level.String())  // Output: \"High\"\nfmt.Printf(\"Threat: %v\\n\", level)  // Output: \"Threat: High\"\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"App/execution/","title":"Index","text":""},{"location":"App/execution/#execution","title":"execution","text":"<pre><code>import \"Engine-AntiGinx/App/execution\"\n</code></pre>"},{"location":"App/execution/#index","title":"Index","text":"<ul> <li>type Formatter</li> <li>type Plan</li> </ul>"},{"location":"App/execution/#type-formatter","title":"type Formatter","text":"<p>Formatter defines the contract for converting parsed user input into an actionable execution plan.</p> <p>Implementations of this interface (e.g., HelpFormatter, ScanFormatter) are responsible for interpreting the command parameters and configuring the engine's runtime behavior, strategies, and targets accordingly.</p> <pre><code>type Formatter interface {\n\n    // FormatParameters analyzes the provided list of command parameters and\n    // constructs a detailed execution Plan.\n    //\n    // This method encapsulates the logic for mapping raw user commands (like flags\n    // and arguments) to specific internal strategies, targets, and context settings\n    // required by the engine.\n    //\n    // Parameters:\n    //  - params: A slice of CommandParameter objects derived from the input parser\n    //\n    // Returns:\n    //  - *Plan: A pointer to the fully initialized execution plan ready for the Orchestrator\n    FormatParameters(params []*types.CommandParameter) *Plan\n}\n</code></pre> <p></p>"},{"location":"App/execution/#type-plan","title":"type Plan","text":"<p>Plan represents a complete blueprint for a security scanning task. It encapsulates all necessary configurations, the sequence of tests to be executed, and the specific data required for each test strategy.</p> <p>The structure acts as a Data Transfer Object (DTO) between the ScanFormatter and the JobRunner, ensuring that the execution logic is decoupled from the parameter parsing logic.</p> <p>Field Details:</p> <ul> <li>Target: The base URL or host being tested.</li> <li>AntiBotFlag: A global setting to enable stealth/evasion techniques across all tests.</li> <li>Strategies: An ordered slice of implementations. The order in this slice defines the exact execution sequence of the security tests.</li> <li>Contexts: A lookup map where keys are strategy names (from GetName()) and values are the specific arguments and targets for that strategy.</li> <li>TaskId: A unique identifier for the execution, required when reporting to a backend service (BACK_URL).</li> </ul> <p>Usage:</p> <pre><code>plan := &amp;Plan{\n    Target: \"https://example.com\",\n    Strategies: []strategy.TestStrategy{headerStrat, xssStrat},\n    Contexts: map[string]strategy.TestContext{\n        \"HeaderTest\": {Target: \"...\", Args: []string{\"-v\"}},\n    },\n}\n</code></pre> <pre><code>type Plan struct {\n    Target      string\n    AntiBotFlag bool\n    Strategies  []strategy.TestStrategy\n    Contexts    map[string]strategy.TestContext\n    TaskId      string\n    IsHelp      bool\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"App/execution/formatterImpl/","title":"Index","text":""},{"location":"App/execution/formatterImpl/#formatterimpl","title":"formatterImpl","text":"<pre><code>import \"Engine-AntiGinx/App/execution/formatterImpl\"\n</code></pre>"},{"location":"App/execution/formatterImpl/#index","title":"Index","text":"<ul> <li>func findParam(params []*types.CommandParameter, paramToFind string) int</li> <li>func mapStrategies(params []*types.CommandParameter, target string) ([]strategy.TestStrategy, map[string]strategy.TestContext)</li> <li>type HelpFormatter</li> <li>func NewHelpFormatter() *HelpFormatter</li> <li>func (h *HelpFormatter) FormatParameters(params []*types.CommandParameter) *execution.Plan</li> <li>func (h *HelpFormatter) mapHelpStrategies(params []*types.CommandParameter) ([]strategy.TestStrategy, map[string]strategy.TestContext)</li> <li>type ScanFormatter</li> <li>func InitializeFormatter() *ScanFormatter</li> <li>func (f *ScanFormatter) FormatParameters(params []*types.CommandParameter) *execution.Plan</li> </ul>"},{"location":"App/execution/formatterImpl/#func-findparam","title":"func findParam","text":"<pre><code>func findParam(params []*types.CommandParameter, paramToFind string) int\n</code></pre> <p>findParam is a helper function that performs a linear search through parameters to find a match by name. Returns the index of the parameter or -1 if not found.</p> <p></p>"},{"location":"App/execution/formatterImpl/#func-mapstrategies","title":"func mapStrategies","text":"<pre><code>func mapStrategies(params []*types.CommandParameter, target string) ([]strategy.TestStrategy, map[string]strategy.TestContext)\n</code></pre> <p>mapStrategies iterates through provided parameters to find matching implementations in the strategy registry. It separates the logic of \"what to do\" (Strategy) from \"what data to use\" (Context).</p> <p>Returns:</p> <ul> <li>A slice of TestStrategy: The sequence of tests to be performed.</li> <li>A map of TestContext: Data specific to each strategy, keyed by strategy name.</li> </ul> <p></p>"},{"location":"App/execution/formatterImpl/#type-helpformatter","title":"type HelpFormatter","text":"<pre><code>type HelpFormatter struct {\n}\n</code></pre>"},{"location":"App/execution/formatterImpl/#func-newhelpformatter","title":"func NewHelpFormatter","text":"<pre><code>func NewHelpFormatter() *HelpFormatter\n</code></pre> <p>NewHelpFormatter initializes and returns a new instance of the HelpFormatter.</p> <p>Returns:</p> <ul> <li>*HelpFormatter: A pointer to the newly created HelpFormatter instance</li> </ul> <p></p>"},{"location":"App/execution/formatterImpl/#func-helpformatter-formatparameters","title":"func (*HelpFormatter) FormatParameters","text":"<pre><code>func (h *HelpFormatter) FormatParameters(params []*types.CommandParameter) *execution.Plan\n</code></pre> <p>FormatParameters processes the parsed command parameters to construct an execution plan specifically for help operations.</p> <p>This method enforces strict environment checks:</p> <ol> <li>It validates that the \"BACK_URL\" environment variable is NOT set. If it is, the method panics, as help operations are incompatible with backend mode.</li> <li>If no parameters are provided, it attempts to load a default help strategy.</li> <li>If parameters are present, it maps them to specific help strategies via `mapHelpStrategies`.</li> </ol> <p>Parameters:</p> <ul> <li>params: A slice of CommandParameter objects parsed from user input</li> </ul> <p>Returns:</p> <ul> <li>*execution.Plan: A fully constructed plan containing the target strategies and contexts</li> </ul> <p></p>"},{"location":"App/execution/formatterImpl/#func-helpformatter-maphelpstrategies","title":"func (*HelpFormatter) mapHelpStrategies","text":"<pre><code>func (h *HelpFormatter) mapHelpStrategies(params []*types.CommandParameter) ([]strategy.TestStrategy, map[string]strategy.TestContext)\n</code></pre> <p>mapHelpStrategies transforms a list of command parameters into their corresponding test strategies and execution contexts.</p> <p>It iterates through the provided parameters and retrieves the matching help strategy from the strategy implementation. If a strategy cannot be found for a given parameter name, the method panics.</p> <p>Parameters:</p> <ul> <li>params: The list of parameters to map</li> </ul> <p>Returns:</p> <ul> <li>[]strategy.TestStrategy: A slice of resolved test strategies</li> <li>map[string]strategy.TestContext: A map associating strategy names with their contexts</li> </ul> <p></p>"},{"location":"App/execution/formatterImpl/#type-scanformatter","title":"type ScanFormatter","text":"<pre><code>type ScanFormatter struct{}\n</code></pre>"},{"location":"App/execution/formatterImpl/#func-initializeformatter","title":"func InitializeFormatter","text":"<pre><code>func InitializeFormatter() *ScanFormatter\n</code></pre> <p>InitializeFormatter creates a new instance of the ScanFormatter. It is used to prepare the environment for transforming raw command-line arguments into a structured execution plan.</p> <p></p>"},{"location":"App/execution/formatterImpl/#func-scanformatter-formatparameters","title":"func (*ScanFormatter) FormatParameters","text":"<pre><code>func (f *ScanFormatter) FormatParameters(params []*types.CommandParameter) *execution.Plan\n</code></pre> <p>FormatParameters transforms a slice of CommandParameters into a cohesive Plan. It extracts global flags (like anti-bot detection), maps specific command names to their corresponding test strategies, and validates environment-specific requirements such as TaskId.</p> <p>Arguments:</p> <ul> <li>params: A slice of pointers to CommandParameter, usually provided by the parser.</li> </ul> <p>Panic Behavior:</p> <pre><code>If the environment variable \"BACK_URL\" is set, the function requires a \"--taskId\"\nparameter to be present. If missing, it panics with an error.Error (code 101).\n</code></pre> <p>Returns:</p> <pre><code>A pointer to a Plan ready to be executed by the JobRunner.\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"App/execution/strategy/","title":"Index","text":""},{"location":"App/execution/strategy/#strategy","title":"strategy","text":"<pre><code>import \"Engine-AntiGinx/App/execution/strategy\"\n</code></pre>"},{"location":"App/execution/strategy/#index","title":"Index","text":"<ul> <li>type HelpSection</li> <li>type HelpStrategyResult</li> <li>func (h *HelpStrategyResult) AppendSection(section []HelpSection)</li> <li>func (h *HelpStrategyResult) GetHelpHeader() string</li> <li>func (h *HelpStrategyResult) GetSectionArray() []HelpSection</li> <li>func (h *HelpStrategyResult) HelpHeader(name string)</li> <li>type ReporterType</li> <li>type ResultWrapper</li> <li>func WrapStrategyResult(testResult *Tests.TestResult, helpMessage *HelpStrategyResult) ResultWrapper</li> <li>func (w ResultWrapper) GetHelpMessage() (bool, *HelpStrategyResult)</li> <li>func (w ResultWrapper) GetTestResult() (bool, *Tests.TestResult)</li> <li>type TestContext</li> <li>type TestStrategy</li> </ul>"},{"location":"App/execution/strategy/#type-helpsection","title":"type HelpSection","text":"<p>HelpSection defines a specific block of information within a help page. Examples include \"USAGE\", \"OPTIONS\", or \"DESCRIPTION\".</p> <pre><code>type HelpSection struct {\n    SectionName string\n    SectionData string\n}\n</code></pre> <p></p>"},{"location":"App/execution/strategy/#type-helpstrategyresult","title":"type HelpStrategyResult","text":"<p>HelpStrategyResult represents the structured content of a help command output. It is designed to be parsed by a HelpReporter to generate readable CLI documentation.</p> <pre><code>type HelpStrategyResult struct {\n    helpHeader string\n    sectionArr []HelpSection\n}\n</code></pre> <p></p>"},{"location":"App/execution/strategy/#func-helpstrategyresult-appendsection","title":"func (*HelpStrategyResult) AppendSection","text":"<pre><code>func (h *HelpStrategyResult) AppendSection(section []HelpSection)\n</code></pre> <p>AppendSection adds one or more new sections to the help message.</p> <p>Parameters:</p> <ul> <li>section: A slice of HelpSection objects to append to the existing list</li> </ul> <p></p>"},{"location":"App/execution/strategy/#func-helpstrategyresult-gethelpheader","title":"func (*HelpStrategyResult) GetHelpHeader","text":"<pre><code>func (h *HelpStrategyResult) GetHelpHeader() string\n</code></pre> <p>GetHelpHeader retrieves the main title of the help message.</p> <p>Returns:</p> <ul> <li>string: The currently set header string</li> </ul> <p></p>"},{"location":"App/execution/strategy/#func-helpstrategyresult-getsectionarray","title":"func (*HelpStrategyResult) GetSectionArray","text":"<pre><code>func (h *HelpStrategyResult) GetSectionArray() []HelpSection\n</code></pre> <p>GetSectionArray returns the list of all help sections currently stored.</p> <p>Returns:</p> <ul> <li>[]HelpSection: The slice of help sections</li> </ul> <p></p>"},{"location":"App/execution/strategy/#func-helpstrategyresult-helpheader","title":"func (*HelpStrategyResult) HelpHeader","text":"<pre><code>func (h *HelpStrategyResult) HelpHeader(name string)\n</code></pre> <p>HelpHeader sets the main title or header for the help message.</p> <p>Parameters:</p> <ul> <li>name: The string to be used as the header (e.g., \"General Help\")</li> </ul> <p></p>"},{"location":"App/execution/strategy/#type-reportertype","title":"type ReporterType","text":"<pre><code>type ReporterType int\n</code></pre> <pre><code>const (\n    CLIReporter ReporterType = iota\n    HelpReporter\n)\n</code></pre>"},{"location":"App/execution/strategy/#type-resultwrapper","title":"type ResultWrapper","text":"<p>ResultWrapper encapsulates the outcome of a strategy execution.</p> <p>It serves as a unified transport object sent through the results channel, allowing the system to handle both standard security test results (e.g., vulnerabilities found) and help/usage information (e.g., manual pages) using a single data structure.</p> <pre><code>type ResultWrapper struct {\n    testResult  *Tests.TestResult\n    helpMessage *HelpStrategyResult\n}\n</code></pre> <p></p>"},{"location":"App/execution/strategy/#func-wrapstrategyresult","title":"func WrapStrategyResult","text":"<pre><code>func WrapStrategyResult(testResult *Tests.TestResult, helpMessage *HelpStrategyResult) ResultWrapper\n</code></pre> <p>WrapStrategyResult constructs a new ResultWrapper containing either a test result, a help message.</p> <p>This factory function is used by strategies to package their output before sending it to the reporting layer.</p> <p>Parameters:</p> <ul> <li>testResult: A pointer to the security test results (can be nil if this is a help operation)</li> <li>helpMessage: A pointer to the help data (can be nil if this is a standard test)</li> </ul> <p>Returns:</p> <ul> <li>ResultWrapper: The initialized wrapper struct</li> </ul> <p></p>"},{"location":"App/execution/strategy/#func-resultwrapper-gethelpmessage","title":"func (ResultWrapper) GetHelpMessage","text":"<pre><code>func (w ResultWrapper) GetHelpMessage() (bool, *HelpStrategyResult)\n</code></pre> <p>GetHelpMessage retrieves the underlying help strategy result from the wrapper.</p> <p>It provides a safe way to check if the result contains help documentation.</p> <p>Returns:</p> <ul> <li>bool: True if a help message exists (is not nil), false otherwise</li> <li>*HelpStrategyResult: The pointer to the help message (or nil)</li> </ul> <p></p>"},{"location":"App/execution/strategy/#func-resultwrapper-gettestresult","title":"func (ResultWrapper) GetTestResult","text":"<pre><code>func (w ResultWrapper) GetTestResult() (bool, *Tests.TestResult)\n</code></pre> <p>GetTestResult retrieves the underlying security test result from the wrapper.</p> <p>It provides a safe way to check for the existence of test data.</p> <p>Returns:</p> <ul> <li>bool: True if a test result exists (is not nil), false otherwise</li> <li>*Tests.TestResult: The pointer to the test result (or nil)</li> </ul> <p></p>"},{"location":"App/execution/strategy/#type-testcontext","title":"type TestContext","text":"<p>TestContext encapsulates the specific data required for a TestStrategy to run. It separates the target environment configuration from the test's implementation.</p> <pre><code>type TestContext struct {\n    // Target represents the base URL or host intended for the security scan.\n    Target string\n\n    // Args holds a slice of sub-test identifiers or specific parameters\n    // passed by the user for this particular strategy.\n    Args []string\n}\n</code></pre> <p></p>"},{"location":"App/execution/strategy/#type-teststrategy","title":"type TestStrategy","text":"<p>TestStrategy defines the contract for a family of security testing algorithms. Any new security test (e.g., XSS, Headers, SSL) must implement this interface to be compatible with the application's Orchestrator and Registry.</p> <p>Concurrency: Implementations of Execute are expected to handle their own internal concurrency if necessary, and must signal completion via the provided sync.WaitGroup.</p> <pre><code>type TestStrategy interface {\n    // Execute runs the core logic of the security test.\n    //\n    // Parameters:\n    //   - ctx: Contains the target URL and specific arguments for this test.\n    //   - channel: A thread-safe pipe to stream TestResult objects back to the UI.\n    //   - wg: A synchronization primitive used to coordinate the completion of the test.\n    //   - antiBotFlag: A global setting to toggle evasion techniques during execution.\n    Execute(ctx TestContext, channel chan ResultWrapper, wg *sync.WaitGroup, antiBotFlag bool)\n\n    // GetName returns the unique identifier for the strategy.\n    // This string is used as the command-line flag (e.g., \"--tests\") and as\n    // the key in the strategy registry.\n    GetName() string\n    GetPreferredReporterType() ReporterType\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"App/execution/strategy/strategyImpl/","title":"Index","text":""},{"location":"App/execution/strategy/strategyImpl/#strategyimpl","title":"strategyImpl","text":"<pre><code>import \"Engine-AntiGinx/App/execution/strategy/strategyImpl\"\n</code></pre>"},{"location":"App/execution/strategy/strategyImpl/#index","title":"Index","text":"<ul> <li>Variables</li> <li>func GetHelpStrategy(name string) (strategy.TestStrategy, bool)</li> <li>func GetStrategy(name string) (strategy.TestStrategy, bool)</li> <li>func init()</li> <li>func loadWebsiteContent(target string, useAntiBotDetection bool) *http.Response</li> <li>func performTest(test *Tests.ResponseTest, wg *sync.WaitGroup, results chan\\&lt;- strategy.ResultWrapper, response *http.Response)</li> <li>func registerHelpStrategy(strategy strategy.TestStrategy)</li> <li>func registerStrategy(strategy strategy.TestStrategy)</li> <li>type generalHelpStrategy</li> <li>func NewGeneralHelpStrategy() *generalHelpStrategy</li> <li>func (s *generalHelpStrategy) Execute(ctx strategy.TestContext, channel chan strategy.ResultWrapper, wg *sync.WaitGroup, antiBotFlag bool)</li> <li>func (s *generalHelpStrategy) GetName() string</li> <li>func (s *generalHelpStrategy) GetPreferredReporterType() strategy.ReporterType</li> <li>type headerTestHelp</li> <li>func NewHeaderTestHelp() *headerTestHelp</li> <li>func (h *headerTestHelp) Execute(ctx strategy.TestContext, channel chan strategy.ResultWrapper, wg *sync.WaitGroup, antiBotFlag bool)</li> <li>func (h *headerTestHelp) GetName() string</li> <li>func (h *headerTestHelp) GetPreferredReporterType() strategy.ReporterType</li> <li>type headerTestStrategy</li> <li>func InitializeHeaderStrategy() *headerTestStrategy</li> <li>func (h *headerTestStrategy) Execute(ctx strategy.TestContext, channel chan strategy.ResultWrapper, wg *sync.WaitGroup, antiBotFlag bool)</li> <li>func (h *headerTestStrategy) GetName() string</li> <li>func (h *headerTestStrategy) GetPreferredReporterType() strategy.ReporterType</li> </ul>"},{"location":"App/execution/strategy/strategyImpl/#variables","title":"Variables","text":"<pre><code>var description = []strategy.HelpSection{\n    {\n        SectionName: \"DESCRIPTION\",\n        SectionData: `--tests parameter launches a targeted security analysis of your website's configuration\nand headers. It provides clear, actionable insights by grading security risks on a standard \nscale from \"None\" to \"Critical\" and assigning a confidence score to every finding. Furthermore, it \nautomatically cross-references detected issues with the official NIST NVD database to identify \nknown CVE vulnerabilities.`,\n    },\n    {\n        SectionName: \"OPTIONS\",\n        SectionData: `https, hsts, serv-h-a, csp, cookie-sec, js-obf, xframe, permission-policy, \nx-content-type-options, referrer-policy, cross-origin-x`,\n    },\n}\n</code></pre> <pre><code>var header = \"Headers tests\"\n</code></pre> <pre><code>var helpStrategies = make(map[string]strategy.TestStrategy)\n</code></pre> <pre><code>var name = \"General Help\"\n</code></pre> <pre><code>var sectionsArr = []strategy.HelpSection{\n    {\n        SectionName: `PATTERN`,\n        SectionData: `antiginx [command input strategy][command input strategy related params]`,\n    },\n    {\n        SectionName: `OPTIONS`,\n        SectionData: `command input strategy:\n test - full cli input\n json - json file input\n rawjson - raw json bytes via stdin`,\n    },\n    {\n        SectionName: `USAGE`,\n        SectionData: ` antiginx test --target website.com --tests https hsts\n antiginx json filename.json`,\n    },\n}\n</code></pre> <p>strategies holds the global registry of all available TestStrategy implementations. It is unexported to ensure that the registry can only be modified through controlled internal functions like registerStrategy.</p> <pre><code>var strategies = make(map[string]strategy.TestStrategy)\n</code></pre> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#func-gethelpstrategy","title":"func GetHelpStrategy","text":"<pre><code>func GetHelpStrategy(name string) (strategy.TestStrategy, bool)\n</code></pre>"},{"location":"App/execution/strategy/strategyImpl/#func-getstrategy","title":"func GetStrategy","text":"<pre><code>func GetStrategy(name string) (strategy.TestStrategy, bool)\n</code></pre> <p>GetStrategy retrieves a registered TestStrategy by its identifier. This is the primary entry point for the Formatter or Orchestrator to obtain a specific testing algorithm based on user input.</p> <p>Returns:</p> <ul> <li>TestStrategy: The matching strategy implementation.</li> <li>bool: A boolean indicating whether the strategy was found (true) or not (false).</li> </ul> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#func-init","title":"func init","text":"<pre><code>func init()\n</code></pre> <p>init is a special Go function that runs automatically when the package is initialized. It is used here to bootstrap the registry with core strategies, ensuring they are available as soon as the application starts.</p> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#func-loadwebsitecontent","title":"func loadWebsiteContent","text":"<pre><code>func loadWebsiteContent(target string, useAntiBotDetection bool) *http.Response\n</code></pre> <p>loadWebsiteContent fetches the target website content via HTTP GET request and returns the response for sharing across all test executions. This function performs a single HTTP request to avoid redundant network calls for each test.</p> <p>The function creates an HTTP client with custom headers to identify the scanner and executes a GET request against the target URL. The returned response object is then shared among all concurrent test goroutines.</p> <p>HTTP configuration:</p> <ul> <li>User-Agent: \"AntiGinx-TestClient/1.0\" (identifies the scanner)</li> <li>Method: GET</li> <li>Timeout: Configured in HttpClient wrapper (default: 30 seconds)</li> </ul> <p>The function may panic with httpError if:</p> <ul> <li>Request creation fails (code 100)</li> <li>Network error occurs (code 101)</li> <li>Non-200 status code returned (code 102)</li> <li>Response body reading fails (code 200)</li> <li>Bot protection detected (code 300)</li> </ul> <p>Parameters:</p> <ul> <li>target: The fully qualified URL to request (e.g., \"https://example.com\")</li> </ul> <p>Returns:</p> <ul> <li>*http.Response: Raw HTTP response object to be shared across all tests</li> </ul> <p>Example:</p> <pre><code>response := loadWebsiteContent(\"https://example.com\", true)\n// Response contains headers, body, status code, etc.\n// This single response is analyzed by all tests\n</code></pre> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#func-performtest","title":"func performTest","text":"<pre><code>func performTest(test *Tests.ResponseTest, wg *sync.WaitGroup, results chan&lt;- strategy.ResultWrapper, response *http.Response)\n</code></pre> <p>performTest executes a single security test in a separate goroutine and publishes the result to the shared results channel. This function is designed to be called as a goroutine and implements the worker pattern for concurrent test execution.</p> <p>Workflow:</p> <ol> <li>Wrap HTTP response in ResponseTestParams structure</li> <li>Execute the test's Run method with the parameters</li> <li>Send the TestResult to the results channel</li> <li>Signal completion via WaitGroup (deferred)</li> </ol> <p>The function uses defer wg.Done() to ensure the WaitGroup is always decremented, even if the test panics or encounters an error. This guarantees proper synchronization and prevents deadlocks in the orchestration logic.</p> <p>Concurrency considerations:</p> <ul> <li>Thread-safe: Multiple goroutines can call this function concurrently</li> <li>Shared response: All tests receive the same HTTP response object (read-only)</li> <li>Channel communication: Results are sent to buffered channel (non-blocking)</li> <li>Synchronization: WaitGroup ensures proper cleanup</li> </ul> <p>Parameters:</p> <ul> <li>test: Pointer to the ResponseTest to execute</li> <li>wg: WaitGroup for synchronizing test completion</li> <li>results: Send-only channel for publishing test results</li> <li>response: Shared HTTP response object to analyze</li> </ul> <p>Example usage (called by Orchestrate):</p> <pre><code>wg.Add(1)\ngo performTest(httpsTest, &amp;wg, resultChannel, httpResponse)\n// Test runs concurrently, result sent to channel, WaitGroup decremented\n</code></pre> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#func-registerhelpstrategy","title":"func registerHelpStrategy","text":"<pre><code>func registerHelpStrategy(strategy strategy.TestStrategy)\n</code></pre>"},{"location":"App/execution/strategy/strategyImpl/#func-registerstrategy","title":"func registerStrategy","text":"<pre><code>func registerStrategy(strategy strategy.TestStrategy)\n</code></pre> <p>registerStrategy adds a new TestStrategy to the global registry map. This function acts as a gatekeeper to ensure that every strategy name is unique.</p> <p>Arguments:</p> <ul> <li>strategy: An implementation of the TestStrategy interface.</li> </ul> <p>Panic Behavior:</p> <pre><code>To prevent accidental configuration errors during development or startup,\nthis function panics with an error.Error (code 100) if a strategy with\nthe same name (retrieved via GetName()) is already registered.\n</code></pre> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#type-generalhelpstrategy","title":"type generalHelpStrategy","text":"<pre><code>type generalHelpStrategy struct{}\n</code></pre>"},{"location":"App/execution/strategy/strategyImpl/#func-newgeneralhelpstrategy","title":"func NewGeneralHelpStrategy","text":"<pre><code>func NewGeneralHelpStrategy() *generalHelpStrategy\n</code></pre> <p>NewGeneralHelpStrategy initializes and returns a new instance of the generalHelpStrategy. This strategy is responsible for displaying the main help information and usage patterns.</p> <p>Returns:</p> <ul> <li>*generalHelpStrategy: A pointer to the newly created strategy instance</li> </ul> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#func-generalhelpstrategy-execute","title":"func (*generalHelpStrategy) Execute","text":"<pre><code>func (s *generalHelpStrategy) Execute(ctx strategy.TestContext, channel chan strategy.ResultWrapper, wg *sync.WaitGroup, antiBotFlag bool)\n</code></pre> <p>Execute performs the logic for the general help strategy.</p> <p>Instead of running a security test, this implementation constructs a help message containing usage patterns, options, and examples defined in `sectionsArr`. It runs asynchronously, wrapping the help data into a `HelpStrategyResult` and sending it through the provided channel.</p> <p>Implements:</p> <ul> <li>strategy.TestStrategy.Execute</li> </ul> <p>Parameters:</p> <ul> <li>ctx: The execution context (unused in this specific strategy)</li> <li>channel: The channel to send the constructed help result back to the reporter</li> <li>wg: WaitGroup used to signal the completion of the help generation</li> <li>antiBotFlag: Global evasion flag (unused in this specific strategy)</li> </ul> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#func-generalhelpstrategy-getname","title":"func (*generalHelpStrategy) GetName","text":"<pre><code>func (s *generalHelpStrategy) GetName() string\n</code></pre> <p>GetName returns the unique identifier for this strategy.</p> <p>For the general help strategy, this returns an empty string as it serves as the default fallback or root help command when no specific test is targeted.</p> <p>Implements:</p> <ul> <li>strategy.TestStrategy.GetName</li> </ul> <p>Returns:</p> <ul> <li>string: An empty string identifier</li> </ul> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#func-generalhelpstrategy-getpreferredreportertype","title":"func (*generalHelpStrategy) GetPreferredReporterType","text":"<pre><code>func (s *generalHelpStrategy) GetPreferredReporterType() strategy.ReporterType\n</code></pre> <p>GetPreferredReporterType specifies the type of reporter best suited for this strategy.</p> <p>This strategy mandates the use of `HelpReporter` to ensure the output is formatted as a readable manual/guide rather than a standard test report.</p> <p>Implements:</p> <ul> <li>strategy.TestStrategy.GetPreferredReporterType</li> </ul> <p>Returns:</p> <ul> <li>strategy.ReporterType: Always returns strategy.HelpReporter</li> </ul> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#type-headertesthelp","title":"type headerTestHelp","text":"<pre><code>type headerTestHelp struct{}\n</code></pre>"},{"location":"App/execution/strategy/strategyImpl/#func-newheadertesthelp","title":"func NewHeaderTestHelp","text":"<pre><code>func NewHeaderTestHelp() *headerTestHelp\n</code></pre> <p>NewHeaderTestHelp initializes and returns a new instance of the headerTestHelp strategy. This strategy provides documentation specifically for the \"--tests\" command argument.</p> <p>Returns:</p> <ul> <li>*headerTestHelp: A pointer to the newly created strategy instance</li> </ul> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#func-headertesthelp-execute","title":"func (*headerTestHelp) Execute","text":"<pre><code>func (h *headerTestHelp) Execute(ctx strategy.TestContext, channel chan strategy.ResultWrapper, wg *sync.WaitGroup, antiBotFlag bool)\n</code></pre> <p>Execute performs the logic for the header test help strategy.</p> <p>Instead of running security scans, this method assembles the help documentation regarding the header analysis capabilities (e.g., risk grading, CVE checks) and the list of valid test options (like CSP, HSTS). It wraps this information in a HelpStrategyResult and sends it to the reporting channel asynchronously.</p> <p>Implements:</p> <ul> <li>strategy.TestStrategy.Execute</li> </ul> <p>Parameters:</p> <ul> <li>ctx: The execution context (unused here)</li> <li>channel: The channel to transmit the help result</li> <li>wg: WaitGroup used to signal completion</li> <li>antiBotFlag: Global evasion flag (unused here)</li> </ul> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#func-headertesthelp-getname","title":"func (*headerTestHelp) GetName","text":"<pre><code>func (h *headerTestHelp) GetName() string\n</code></pre> <p>GetName returns the unique identifier for this strategy, which corresponds to the CLI flag used to invoke the security tests.</p> <p>Implements:</p> <ul> <li>strategy.TestStrategy.GetName</li> </ul> <p>Returns:</p> <ul> <li>string: Returns \"--tests\"</li> </ul> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#func-headertesthelp-getpreferredreportertype","title":"func (*headerTestHelp) GetPreferredReporterType","text":"<pre><code>func (h *headerTestHelp) GetPreferredReporterType() strategy.ReporterType\n</code></pre> <p>GetPreferredReporterType specifies the type of reporter required for this strategy.</p> <p>Since this is a help strategy, it mandates the use of HelpReporter to format the output as user documentation.</p> <p>Implements:</p> <ul> <li>strategy.TestStrategy.GetPreferredReporterType</li> </ul> <p>Returns:</p> <ul> <li>strategy.ReporterType: Always returns strategy.HelpReporter</li> </ul> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#type-headerteststrategy","title":"type headerTestStrategy","text":"<p>headerTestStrategy implements the strategy.TestStrategy interface. It is responsible for orchestrating header-based security assessments by fetching target content and executing a suite of sub-tests concurrently.</p> <pre><code>type headerTestStrategy struct{}\n</code></pre> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#func-initializeheaderstrategy","title":"func InitializeHeaderStrategy","text":"<pre><code>func InitializeHeaderStrategy() *headerTestStrategy\n</code></pre> <p>InitializeHeaderStrategy returns a pointer to a new headerTestStrategy. It acts as the constructor for the header-based testing logic.</p> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#func-headerteststrategy-execute","title":"func (*headerTestStrategy) Execute","text":"<pre><code>func (h *headerTestStrategy) Execute(ctx strategy.TestContext, channel chan strategy.ResultWrapper, wg *sync.WaitGroup, antiBotFlag bool)\n</code></pre> <p>Execute performs the strategy logic by fetching the target website's content and spawning asynchronous sub-tests for each provided argument.</p> <p>Concurrency Model:</p> <ul> <li>It utilizes a sync.WaitGroup to track the lifecycle of spawned goroutines.</li> <li>Results are streamed back to the orchestrator via the provided result channel.</li> </ul> <p>Logic Flow:</p> <ol> <li>Formats the target URL using the targetFormatter helper.</li> <li>Fetches the raw website content (respecting the antiBotFlag).</li> <li>Iterates through ctx.Args to identify specific sub-tests in the Registry.</li> <li>Launches each valid sub-test in its own goroutine.</li> </ol> <p>Panic Behavior:</p> <pre><code>If an argument corresponds to a test ID that does not exist in the Registry,\nthe function panics with an error.Error (code 100), which is caught by the\nglobal ErrorHandler.\n</code></pre> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#func-headerteststrategy-getname","title":"func (*headerTestStrategy) GetName","text":"<pre><code>func (h *headerTestStrategy) GetName() string\n</code></pre> <p>GetName returns the command-line flag identifier associated with this strategy. This name is used by the Registry to map the \"--tests\" parameter to this implementation.</p> <p></p>"},{"location":"App/execution/strategy/strategyImpl/#func-headerteststrategy-getpreferredreportertype","title":"func (*headerTestStrategy) GetPreferredReporterType","text":"<pre><code>func (h *headerTestStrategy) GetPreferredReporterType() strategy.ReporterType\n</code></pre> <p>GetPreferredReporterType returns the default ReporterType that should be used when running this strategy in the absence of any environment-based override.</p> <p>Centralized configuration (for example, environment variables such as BACK_URL) may override this preference at runtime to route results to a different reporter, but individual strategies should declare their preferred type to keep behavior consistent as more reporter types are introduced.</p> <p>Generated by gomarkdoc</p>"},{"location":"App/parser/","title":"Parameter-Parser","text":""},{"location":"App/parser/#parser","title":"parser","text":"<pre><code>import \"Engine-AntiGinx/App/parser\"\n</code></pre>"},{"location":"App/parser/#index","title":"Index","text":"<ul> <li>Variables</li> <li>type Parser</li> <li>type Resolver</li> <li>func CreateResolver() *Resolver</li> <li>func (p *Resolver) Resolve(userParameters []string) (Parser, execution.Formatter)</li> <li>type parserEntry</li> </ul>"},{"location":"App/parser/#variables","title":"Variables","text":"<p>whiteList serves as a registry mapping command strings (e.g., \"json\", \"test\") to their corresponding Parser implementations. This map is initialized on startup and effectively acts as a strategy pattern registry.</p> <pre><code>var whiteList = map[string]parserEntry{\n\n    \"test\": {\n        workerReference:    impl.CreateCommandParser(),\n        formatterReference: impl2.InitializeFormatter(),\n    },\n\n    \"json\": {\n        workerReference:    impl.CreateJsonParser(helpers.CreateFileReader()),\n        formatterReference: impl2.InitializeFormatter(),\n    },\n\n    \"rawjson\": {\n        workerReference:    impl.CreateRawJsonParser(os.Stdin),\n        formatterReference: impl2.InitializeFormatter(),\n    },\n\n    \"help\": {\n        workerReference:    impl.CreateHelpParser(),\n        formatterReference: impl2.NewHelpFormatter(),\n    },\n}\n</code></pre> <p></p>"},{"location":"App/parser/#type-parser","title":"type Parser","text":"<p>Parser defines the interface for strategies that process user input. Any component that translates raw command-line arguments into structured application parameters must implement this interface.</p> <pre><code>type Parser interface {\n    // Parse takes a slice of raw string arguments (usually from os.Args)\n    // and transforms them into a list of structured CommandParameter objects.\n    //\n    // It returns a slice of pointers to CommandParameter, ready to be used by the application core.\n    // Note: Implementations may panic if the input data violates validation rules.\n    Parse(userParameters []string) []*types.CommandParameter\n}\n</code></pre> <p></p>"},{"location":"App/parser/#type-resolver","title":"type Resolver","text":"<p>Resolver is responsible for selecting the appropriate Parser implementation based on the command-line arguments provided by the user. It acts as a router that directs execution to the specific worker (e.g., JsonParser, CommandParser).</p> <pre><code>type Resolver struct{}\n</code></pre> <p></p>"},{"location":"App/parser/#func-createresolver","title":"func CreateResolver","text":"<pre><code>func CreateResolver() *Resolver\n</code></pre> <p>CreateResolver initializes and returns a new instance of the Resolver service.</p> <p></p>"},{"location":"App/parser/#func-resolver-resolve","title":"func (*Resolver) Resolve","text":"<pre><code>func (p *Resolver) Resolve(userParameters []string) (Parser, execution.Formatter)\n</code></pre> <p>Resolve determines which Parser to use by inspecting the second argument (index 1) of the provided parameters (usually os.Args).</p> <p>It performs the following checks:</p> <ul> <li>Verifies that enough parameters are provided (requires at least 2: [executable, command]).</li> <li>Looks up the command in the internal whitelist.</li> </ul> <p>Returns the matching Parser interface if successful. Panics if:</p> <ul> <li>Fewer than 2 arguments are provided (Error 100).</li> <li>The requested worker/command is not found in the whitelist (Error 101).</li> </ul> <p></p>"},{"location":"App/parser/#type-parserentry","title":"type parserEntry","text":"<p>parserEntry is a wrapper struct used internally to hold a reference to a concrete Parser instance.</p> <pre><code>type parserEntry struct {\n    workerReference    Parser\n    formatterReference execution.Formatter\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"App/parser/config/","title":"Index","text":""},{"location":"App/parser/config/#config","title":"config","text":"<pre><code>import \"Engine-AntiGinx/App/parser/config\"\n</code></pre>"},{"location":"App/parser/config/#index","title":"Index","text":"<ul> <li>Variables</li> </ul>"},{"location":"App/parser/config/#variables","title":"Variables","text":"<p>Params is the static registry of all supported command-line parameters with their configurations. Each parameter defines:</p> <ul> <li>Arguments: Whitelist of allowed values (empty means any value accepted)</li> <li>DefaultVal: Default value when parameter is provided without arguments</li> <li>ArgRequired: Whether arguments are mandatory</li> <li>ArgCount: Number of arguments (1 for single, -1 for multiple)</li> </ul> <pre><code>var Params = map[string]types.Parameter{\n    \"--target\": {\n        Arguments:   []string{},\n        DefaultVal:  \"\",\n        ArgRequired: true,\n        ArgCount:    1,\n    },\n    \"--taskId\": {\n        Arguments:   []string{},\n        DefaultVal:  \"\",\n        ArgRequired: true,\n        ArgCount:    1,\n    },\n    \"--userAgent\": {\n        Arguments:   []string{},\n        DefaultVal:  \"Scanner/1.0\",\n        ArgRequired: false,\n        ArgCount:    1,\n    },\n\n    \"--tests\": {\n        Arguments: []string{\"https\", \"hsts\", \"serv-h-a\", \"csp\", \"cookie-sec\", \"js-obf\", \"xframe\", \"permissions-policy\", \"x-content-type-options\", \"referrer-policy\", \"cross-origin-x\"},\n\n        DefaultVal:  \"\",\n        ArgRequired: true,\n        ArgCount:    -1,\n    },\n\n    \"--antiBotDetection\": {\n        Arguments:   []string{},\n        DefaultVal:  \"\",\n        ArgRequired: false,\n        ArgCount:    0,\n    },\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"App/parser/config/types/","title":"Index","text":""},{"location":"App/parser/config/types/#types","title":"types","text":"<pre><code>import \"Engine-AntiGinx/App/parser/config/types\"\n</code></pre>"},{"location":"App/parser/config/types/#index","title":"Index","text":"<ul> <li>type CliParserTest</li> <li>type CommandParameter</li> <li>type DesHelpTest</li> <li>type JsonParserTest</li> <li>type Parameter</li> <li>type TestJson</li> </ul>"},{"location":"App/parser/config/types/#type-cliparsertest","title":"type CliParserTest","text":"<pre><code>type CliParserTest struct {\n    Name    string\n    Params  []string\n    WantErr bool\n    Want    []*CommandParameter\n}\n</code></pre>"},{"location":"App/parser/config/types/#type-commandparameter","title":"type CommandParameter","text":"<p>CommandParameter represents a parsed command-line parameter with its associated arguments. This is the output structure returned by the parser after successful validation.</p> <pre><code>type CommandParameter struct {\n    Name      string   `json:\"Name\"`      // Parameter name (e.g., \"--target\", \"--tests\")\n    Arguments []string `json:\"Arguments\"` // List of validated arguments for this parameter\n}\n</code></pre> <p></p>"},{"location":"App/parser/config/types/#type-deshelptest","title":"type DesHelpTest","text":"<pre><code>type DesHelpTest struct {\n    Name       string\n    ExpErrCode int\n    Filename   string\n}\n</code></pre>"},{"location":"App/parser/config/types/#type-jsonparsertest","title":"type JsonParserTest","text":"<pre><code>type JsonParserTest struct {\n    Name         string\n    Params       []string\n    WantErrCode  int\n    Want         []*CommandParameter\n    DataToReturn []byte\n    FileName     string\n    ErrToReturn  error\n}\n</code></pre>"},{"location":"App/parser/config/types/#type-parameter","title":"type Parameter","text":"<pre><code>type Parameter struct {\n    Arguments   []string // Whitelist of allowed argument values (empty = no restriction)\n    DefaultVal  string   // Default value when parameter provided without arguments\n    ArgRequired bool     // Whether the parameter must have arguments\n    ArgCount    int      // Expected argument count: 1 for single, -1 for multiple\n}\n</code></pre>"},{"location":"App/parser/config/types/#type-testjson","title":"type TestJson","text":"<p>TestJson represents the root structure of the configuration file. It maps directly to the JSON input containing the target URL and a list of parameters.</p> <pre><code>type TestJson struct {\n    Target     string              `json:\"Target\"`\n    Parameters []*CommandParameter `json:\"Parameters\"`\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"App/parser/impl/","title":"Index","text":""},{"location":"App/parser/impl/#impl","title":"impl","text":"<pre><code>import \"Engine-AntiGinx/App/parser/impl\"\n</code></pre> <p>Package impl provides CLI argument parsing functionality for the Engine-AntiGinx scanner. It processes command-line tokens based on statically defined parameter definitions, validates required arguments, enforces whitelists, and provides structured error reporting through panic-based error handling.</p> <p>The parser supports various parameter types including:</p> <ul> <li>Single-value parameters (--target, --userAgent)</li> <li>Multi-value parameters (--tests, --httpMethods)</li> <li>Optional parameters with defaults (--userAgent, --referer)</li> <li>Required parameters (--target, --tests, --httpMethods)</li> <li>Whitelist validation for specific parameters</li> </ul> <p>Error codes:</p> <ul> <li>100: Insufficient parameters</li> <li>201: Missing \"test\" keyword or invalid command structure</li> <li>303: Missing required arguments</li> <li>304: Invalid argument or unexpected parameter</li> <li>305: Duplicate argument detected</li> <li>306: Too many arguments for single-value parameter</li> </ul>"},{"location":"App/parser/impl/#index","title":"Index","text":"<ul> <li>func checkOccurrences(args []string)</li> <li>func findElement(userParam string, params []string) bool</li> <li>func transformIntoTable(params map[string]types.Parameter, userParameters []string) []*types.CommandParameter</li> <li>type HelpParser</li> <li>func CreateHelpParser() *HelpParser</li> <li>func (h *HelpParser) Parse(userParameters []string) []*types.CommandParameter</li> <li>type JsonParser</li> <li>func CreateJsonParser(fileReader helpers.FileReader) *JsonParser</li> <li>func (j *JsonParser) Parse(userParameters []string) []*types.CommandParameter</li> <li>func (j *JsonParser) deserializeWithErrorHandling(fileName string) *types.TestJson</li> <li>func (j *JsonParser) throwPanic(code int, message string)</li> <li>type RawJsonParser</li> <li>func CreateRawJsonParser(source io.Reader) *RawJsonParser</li> <li>func (rj *RawJsonParser) Parse(userParameters []string) []*types.CommandParameter</li> <li>type parameterParser</li> <li>func CreateCommandParser() *parameterParser</li> <li>func (p *parameterParser) Parse(userParameters []string) []*types.CommandParameter</li> </ul>"},{"location":"App/parser/impl/#func-checkoccurrences","title":"func checkOccurrences","text":"<pre><code>func checkOccurrences(args []string)\n</code></pre> <p>checkOccurrences validates that no argument appears more than once in the argument list. This prevents duplicate values which could indicate user error or misconfiguration.</p> <p>The function uses a map to track seen arguments with O(n) time complexity.</p> <p>Parameters:</p> <ul> <li>args: List of arguments to check for duplicates</li> </ul> <p>Panics:</p> <ul> <li>error.Error with code 305: If any argument appears more than once</li> </ul> <p>Example:</p> <pre><code>args := []string{\"https\", \"hsts\", \"https\"}  // panics - \"https\" appears twice\nargs := []string{\"GET\", \"POST\", \"PUT\"}      // passes - all unique\n</code></pre> <p></p>"},{"location":"App/parser/impl/#func-findelement","title":"func findElement","text":"<pre><code>func findElement(userParam string, params []string) bool\n</code></pre> <p>findElement performs a linear search to check if a user-provided argument exists in the parameter's whitelist of allowed values. This is used for validating arguments against parameter definitions that specify allowed values.</p> <p>Parameters:</p> <ul> <li>userParam: The argument value provided by the user</li> <li>Params: Whitelist of allowed values for the parameter</li> </ul> <p>Returns:</p> <ul> <li>bool: true if userParam is found in the whitelist, false otherwise</li> </ul> <p>Example:</p> <pre><code>allowed := []string{\"GET\", \"POST\", \"PUT\"}\nisValid := findElement(\"GET\", allowed)  // returns true\nisValid := findElement(\"INVALID\", allowed)  // returns false\n</code></pre> <p></p>"},{"location":"App/parser/impl/#func-transformintotable","title":"func transformIntoTable","text":"<pre><code>func transformIntoTable(params map[string]types.Parameter, userParameters []string) []*types.CommandParameter\n</code></pre> <p>transformIntoTable is the core parsing algorithm that transforms and validates user input into a structured list of CommandParameter objects. It implements a state machine that distinguishes between parameter names and their arguments.</p> <p>Algorithm overview:</p> <p>The parser uses an \"argMode\" flag to track whether it's currently collecting arguments:</p> <p>For each token (starting from index 2):</p> <ol> <li> <p>If token is a known parameter: - If argMode is ON: finalize the previous parameter's arguments - Validate argument count and check for duplicates - If current parameter requires arguments: enter argMode - If optional: check next token and use default or provided value</p> </li> <li> <p>If token is NOT a parameter: - If argMode is OFF: panic (unexpected argument) - If argMode is ON: validate against whitelist and collect argument</p> </li> </ol> <p>After processing all tokens, if argMode is still on, the last parameter is finalized.</p> <p>Variables:</p> <pre><code>parsedParams   Output list of parsed parameters.\ncurrentParam   Name of the parameter currently collecting arguments.\nargs           Buffer for collecting argument values.\nargMode        State flag indicating argument collection mode.\n</code></pre> <p>Parameters:</p> <pre><code>Params         Map of parameter definitions for validation.\nuserParameters Raw command-line tokens to parse.\n</code></pre> <p>Returns:</p> <pre><code>[]*CommandParameter: Validated list of parameters with arguments.\n</code></pre> <p>Panics:</p> <pre><code>error.Error with code 303: Missing required arguments or empty argument list.\nerror.Error with code 304: Invalid argument or unexpected token.\nerror.Error with code 305: Duplicate arguments detected.\nerror.Error with code 306: Too many arguments for single-value parameter.\n</code></pre> <p></p>"},{"location":"App/parser/impl/#type-helpparser","title":"type HelpParser","text":"<pre><code>type HelpParser struct{}\n</code></pre>"},{"location":"App/parser/impl/#func-createhelpparser","title":"func CreateHelpParser","text":"<pre><code>func CreateHelpParser() *HelpParser\n</code></pre> <p>CreateHelpParser initializes and returns a new instance of the HelpParser struct. This function serves as the constructor for the help parser.</p> <p>Returns:</p> <ul> <li>*HelpParser: A pointer to the newly created HelpParser instance</li> </ul> <p></p>"},{"location":"App/parser/impl/#func-helpparser-parse","title":"func (*HelpParser) Parse","text":"<pre><code>func (h *HelpParser) Parse(userParameters []string) []*types.CommandParameter\n</code></pre> <p>Parse processes the raw user input arguments (slice of strings) and converts them into a list of CommandParameter objects.</p> <p>The method ignores the first two elements of `userParameters` (assuming they are the executable name and the \"help\" command itself) and iterates through the remaining arguments. Each argument is validated against the global configuration. If an argument is not recognized, the function will panic.</p> <p>Parameters:</p> <ul> <li>userParameters: The slice of input arguments provided by the user (e.g. os.Args)</li> </ul> <p>Returns:</p> <ul> <li>[]*types.CommandParameter: A list of constructed command parameter objects</li> </ul> <p>Example:</p> <pre><code>args := []string{\"scanner\", \"help\", \"--tests\"}\nparser := CreateHelpParser()\n// Returns command parameters for \"--tests\"\ncommands := parser.Parse(args)\n</code></pre> <p></p>"},{"location":"App/parser/impl/#type-jsonparser","title":"type JsonParser","text":"<p>JsonParser is responsible for reading configuration logic from a JSON file and error handling. Logic of deserialization and validation moved to deserialize helper</p> <pre><code>type JsonParser struct {\n    fileReader helpers.FileReader\n}\n</code></pre> <p></p>"},{"location":"App/parser/impl/#func-createjsonparser","title":"func CreateJsonParser","text":"<pre><code>func CreateJsonParser(fileReader helpers.FileReader) *JsonParser\n</code></pre> <p>CreateJsonParser initializes and returns a new instance of JsonParser.</p> <p></p>"},{"location":"App/parser/impl/#func-jsonparser-parse","title":"func (*JsonParser) Parse","text":"<pre><code>func (j *JsonParser) Parse(userParameters []string) []*types.CommandParameter\n</code></pre> <p>Parse orchestrates the parsing process. It expects userParameters to contain the filename at index 2. It reads the file, validates parameters against defined rules, and returns a consolidated list of CommandParameter objects.</p> <p>It prepends the target as a \"--target\" parameter to the final list. This method panics if validation fails or the file cannot be read.</p> <p></p>"},{"location":"App/parser/impl/#func-jsonparser-deserializewitherrorhandling","title":"func (*JsonParser) deserializeWithErrorHandling","text":"<pre><code>func (j *JsonParser) deserializeWithErrorHandling(fileName string) *types.TestJson\n</code></pre> <p>deserializeWithErrorHandling reads the file from the disk and unmarshalls it into a TestJson struct. It handles file I/O errors and JSON syntax errors by triggering a panic with a descriptive message.</p> <p></p>"},{"location":"App/parser/impl/#func-jsonparser-throwpanic","title":"func (*JsonParser) throwPanic","text":"<pre><code>func (j *JsonParser) throwPanic(code int, message string)\n</code></pre> <p>throwPanic is a helper method to construct and panic with a standard application Error. This is used to interrupt the control flow when a validation or parsing error occurs.</p> <p></p>"},{"location":"App/parser/impl/#type-rawjsonparser","title":"type RawJsonParser","text":"<pre><code>type RawJsonParser struct {\n    inputSource io.Reader\n}\n</code></pre>"},{"location":"App/parser/impl/#func-createrawjsonparser","title":"func CreateRawJsonParser","text":"<pre><code>func CreateRawJsonParser(source io.Reader) *RawJsonParser\n</code></pre>"},{"location":"App/parser/impl/#func-rawjsonparser-parse","title":"func (*RawJsonParser) Parse","text":"<pre><code>func (rj *RawJsonParser) Parse(userParameters []string) []*types.CommandParameter\n</code></pre>"},{"location":"App/parser/impl/#type-parameterparser","title":"type parameterParser","text":"<p>parameterParser is the main parser structure that processes command-line arguments. It uses the static Params map for parameter definitions and validation rules.</p> <pre><code>type parameterParser struct{}\n</code></pre> <p></p>"},{"location":"App/parser/impl/#func-createcommandparser","title":"func CreateCommandParser","text":"<pre><code>func CreateCommandParser() *parameterParser\n</code></pre> <p>CreateCommandParser creates a new instance of the parameter parser. This factory function returns a parser ready to process command-line arguments.</p> <p>Returns:</p> <ul> <li>*parameterParser: A new parser instance</li> </ul> <p>Example:</p> <pre><code>parser := CreateCommandParser()\nParams := parser.Parse(os.Args)\n</code></pre> <p></p>"},{"location":"App/parser/impl/#func-parameterparser-parse","title":"func (*parameterParser) Parse","text":"<pre><code>func (p *parameterParser) Parse(userParameters []string) []*types.CommandParameter\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"Engined/","title":"Daemon","text":""},{"location":"Engined/#engined","title":"Engined","text":"<pre><code>import \"Engine-AntiGinx/Engined\"\n</code></pre> <p>Package main provides the Engine-AntiGinx daemon (Engined) that listens for security scan tasks from a RabbitMQ message queue and executes them asynchronously.</p> <p>Engined acts as a background worker service that:</p> <ul> <li>Connects to RabbitMQ and consumes messages from \"scan_queue\"</li> <li>Parses incoming JSON task payloads containing target URLs</li> <li>Spawns the Engine-AntiGinx scanner for each task</li> <li>Handles graceful shutdown on interrupt signals (SIGINT)</li> </ul> <p>Architecture:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Backend    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502  RabbitMQ   \u2502\u2500\u2500\u2500\u2500\u25b6\u2502  Engined        \u2502\n\u2502  (Producer) \u2502     \u2502  scan_queue \u2502     \u2502  (Consumer)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                 \u2502\n                                                 \u25bc\n                                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                        \u2502  Engine-AntiGinx\u2502\n                                        \u2502  Scanner (App)  \u2502\n                                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Environment Variables:</p> <ul> <li>RABBITMQ_URL: Connection string for RabbitMQ (required) Example: amqp://guest:guest@localhost:5672/</li> </ul> <p>Message Format (JSON):</p> <pre><code>{\n    \"id\": \"task-uuid-123\",\n    \"target_url\": \"https://example.com\"\n}\n</code></pre> <p>Error Handling:</p> <ul> <li>Invalid JSON messages are NACK'd without requeue</li> <li>Scanner execution errors are NACK'd without requeue</li> <li>Successful scans are ACK'd to remove from queue</li> </ul> <p>Graceful Shutdown:</p> <p>The daemon handles SIGINT (Ctrl+C) gracefully by:</p> <ol> <li>Setting shutdown flag to prevent new task processing</li> <li>Completing any in-progress task</li> <li>Closing RabbitMQ connections</li> <li>Exiting cleanly</li> </ol>"},{"location":"Engined/#index","title":"Index","text":"<ul> <li>func consumeSafe(msgs \\&lt;-chan amqp.Delivery, isShuttingDown *bool, errMidConn chan *amqp.Error, closeChannel chan os.Signal)</li> <li>func handleScanError(stderrBuff *bytes.Buffer, msg amqp.Delivery)</li> <li>func main()</li> <li>func runScan(messageBody []byte, stderrBuff *bytes.Buffer) error</li> <li>type EngineTask</li> <li>type RabbitConfig</li> <li>func configureRabbitConnection(queueUrl string) (*RabbitConfig, error)</li> </ul>"},{"location":"Engined/#func-consumesafe","title":"func consumeSafe","text":"<pre><code>func consumeSafe(msgs &lt;-chan amqp.Delivery, isShuttingDown *bool, errMidConn chan *amqp.Error, closeChannel chan os.Signal)\n</code></pre>"},{"location":"Engined/#func-handlescanerror","title":"func handleScanError","text":"<pre><code>func handleScanError(stderrBuff *bytes.Buffer, msg amqp.Delivery)\n</code></pre>"},{"location":"Engined/#func-main","title":"func main","text":"<pre><code>func main()\n</code></pre> <p>main is the entry point for the Engine-AntiGinx daemon. It establishes a connection to RabbitMQ, sets up message consumption, and enters an infinite loop to process incoming scan tasks.</p> <p>The daemon performs the following steps:</p> <ol> <li>Set up interrupt signal handling for graceful shutdown</li> <li>Read RABBITMQ_URL from environment variables</li> <li>Establish connection to RabbitMQ</li> <li>Create a channel and start consuming from \"scan_queue\"</li> <li>Process each message by spawning the scanner subprocess</li> <li>ACK/NACK messages based on processing success</li> <li>Handle graceful shutdown on SIGINT</li> </ol> <p>The main loop uses a select statement to handle:</p> <ul> <li>Incoming messages from RabbitMQ</li> <li>Interrupt signals for shutdown</li> </ul> <p>Environment Requirements:</p> <ul> <li>RABBITMQ_URL must be set</li> <li>RabbitMQ server must be accessible</li> <li>\"scan_queue\" must exist in RabbitMQ</li> </ul> <p></p>"},{"location":"Engined/#func-runscan","title":"func runScan","text":"<pre><code>func runScan(messageBody []byte, stderrBuff *bytes.Buffer) error\n</code></pre>"},{"location":"Engined/#type-enginetask","title":"type EngineTask","text":"<p>EngineTask represents a security scan task received from the message queue. It contains the necessary information to execute a security assessment against a target URL.</p> <p>Fields:</p> <ul> <li>Id: Unique identifier for the task, used for tracking and reporting</li> <li>Target: The URL to scan (e.g., \"https://example.com\")</li> </ul> <p>JSON Example:</p> <pre><code>{\n    \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"target_url\": \"https://example.com\"\n}\n</code></pre> <pre><code>type EngineTask struct {\n    Id     string `json:\"id\"`\n    Target string `json:\"target_url\"`\n}\n</code></pre> <p></p>"},{"location":"Engined/#type-rabbitconfig","title":"type RabbitConfig","text":"<pre><code>type RabbitConfig struct {\n    ConnCh       *amqp.Connection\n    TaskCh       *amqp.Channel\n    ErrMidConnCh chan *amqp.Error\n}\n</code></pre>"},{"location":"Engined/#func-configurerabbitconnection","title":"func configureRabbitConnection","text":"<pre><code>func configureRabbitConnection(queueUrl string) (*RabbitConfig, error)\n</code></pre> <p>Generated by gomarkdoc</p>"}]}